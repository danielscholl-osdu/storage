diff --git a/docs/api/storage_openapi.yaml b/docs/api/storage_openapi.yaml
index c3fb6dcd6cc22556a02e87b7f4bcdd39cc8757ca..299e6bd915daf8977f43e595885318a2f85f605a 100644
--- a/docs/api/storage_openapi.yaml
+++ b/docs/api/storage_openapi.yaml
@@ -23,6 +23,8 @@ tags:
     description: Copying record references management operations
   - name: records
     description: Records management operations
+  - name: info
+    description: Replay records
   - name: info
     description: Version info endpoint
 paths:
@@ -1215,6 +1217,156 @@ paths:
                 $ref: '#/components/schemas/AppError'
       security:
         - Authorization: []
+
+  /replay/status/{id}:
+    get:
+      tags:
+        - replay
+      summary: get status of replay operation
+      description: |-
+        By passing replayId , you can get the replay operation status. 
+        Allowed roles: `users.datalake.ops`
+      parameters:
+        - name: id
+          in: path
+          description: replayId
+          required: true
+          schema:
+            type: string
+        - name: data-partition-id
+          in: header
+          description: Tenant Id
+          required: true
+          schema:
+            type: string
+      responses:
+        "200":
+          description: search results matching criteria and returns details of replay operation.
+          content:
+            application/json:
+              schema:
+                type: array
+                items:
+                  $ref: '#/components/schemas/ReplayStatus'
+              examples:
+                Status:
+                  $ref: '#/components/examples/Status'
+                StatusFailed:
+                  $ref: '#/components/examples/StatusFailed'
+                StatusFailedForKind:
+                  $ref: '#/components/examples/StatusFailedForKind'
+                StatusPassedForKind:
+                  $ref: '#/components/examples/StatusPassedForKind'
+
+        "500":
+          description: Internal Server Error
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/AppError'
+        "502":
+          description: Bad Gateway
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/AppError'
+        "503":
+          description: Service Unavailable
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/AppError'
+        "403":
+          description: Forbidden
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/AppError'
+        "401":
+          description: Unauthorized
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/AppError'
+        "404":
+          description: Record not found.
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/AppError'
+    security:
+      - Authorization: []
+  /replay:
+    post:
+      tags:
+        - replay
+      summary: replay based on type
+      description:
+        Replay all the kinds. Allowed roles `users.datalake.ops`
+      parameters:
+        - name: data-partition-id
+          in: header
+          description: Tenant Id
+          required: true
+          schema:
+          type: string
+      requestBody:
+        description: replay based on type
+        content:
+          application/json:
+            schema:
+              $ref: '#/components/schemas/ReplayRequest'
+            examples:
+              KindAll:
+                $ref: '#/components/examples/KindAll'
+              Kinds:
+                $ref: '#/components/examples/Kinds'
+      responses:
+        "202":
+          description: A response object
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/Status'
+        "500":
+        description: Internal Server Error
+        content:
+          application/json:
+            schema:
+              $ref: '#/components/schemas/AppError'
+      "502":
+        description: Bad Gateway
+        content:
+          application/json:
+            schema:
+              $ref: '#/components/schemas/AppError'
+      "503":
+        description: Service Unavailable
+        content:
+          application/json:
+            schema:
+              $ref: '#/components/schemas/AppError'
+      "403":
+        description: Forbidden
+        content:
+          application/json:
+            schema:
+              $ref: '#/components/schemas/AppError'
+      "401":
+        description: Unauthorized
+        content:
+          application/json:
+            schema:
+              $ref: '#/components/schemas/AppError'
+      "404":
+        description: Record not found.
+        content:
+          application/json:
+            schema:
+              $ref: '#/components/schemas/AppError'
+      security:
+        - Authorization: []
+
   /whoami:
     get:
       tags:
@@ -1804,6 +1956,176 @@ components:
           type: array
           items:
             $ref: '#/components/schemas/ConnectedOuterService'
+    ReplayRequest:
+      type: object
+      required:
+        - operation
+      properties:
+        operation:
+          type: string
+        filter:
+          anyOf:
+            - $ref: '#/components/schemas/Kind'
+    ReplayStatus:
+      required:
+        - replayId
+        - operation
+        - totalRecords
+        - processedRecords
+        - overallState
+        - totalTime
+        - status
+      type: object
+      properties:
+        kind:
+          type: string
+        replayId:
+          type: string
+        totalRecords:
+          type: integer
+          format: int64
+        processedRecords:
+          type: integer
+          format: int64
+        overallState:
+          type: string
+        startedAt:
+          type: string
+          format: date
+        filter:
+          type: array
+          items:
+            type: object
+        status:
+          type: array
+          items:
+            type: object
+          properties:
+            kind:
+              type: string
+            totalRecords:
+              type: integer
+              format: int64
+            processedRecords:
+              type: integer
+              format: int64
+            state:
+              type: string
+            startedAt:
+              type: string
+              format: date
+            elapsedTime:
+              type: string
+              format: duration
+            avgProcessingTimePerMinute:
+              type: integer
+              format: int64
+    Status:
+      required:
+        - replayId
+      type: object
+      properties:
+        replayId:
+          type: integer
+          example: 1000
+    Kind:
+      type: array
+      items:
+        type: string
+        example: "osdu:wks:reference-data--VelocityAnalysisMethod:1.0.0"
+  examples:
+    KindAll:
+      value:
+        operation: reindex
+    Kinds:
+      value:
+        operation: reindex
+        filter: {"kinds":["osdu:wks:reference-data--VelocityAnalysisMethod:1.0.0"]}
+    Status:
+      value:
+        replayId: "1000"
+        operation: "reindex"
+        totalRecordsOverall: 2
+        processedRecordsOverall: 1
+        startedAt: 2023-07-21T17:32:28Z
+        OverallState: IN_PROGRESS
+        filter: {}
+        status:
+          [
+            {
+              kind: "*",
+              totalRecords: 2,
+              processedRecords: 1,
+              state: "IN_PROGRESS",
+              startedAt: "2023-07-21T17:32:28Z",
+              elapsedTime: "23",
+              avgProcessingTimePerMinute: "1",
+            }
+          ]
+    StatusFailed:
+      value:
+        replayId: "1000"
+        operation: "reindex"
+        totalRecords: 2
+        processedRecords: 1
+        startedAt: 2023-07-21T17:32:28Z
+        state: "FAILED"
+        filter: {}
+        status:
+          [
+            {
+              kind: "*",
+              totalRecords: 2,
+              processedRecords: 1,
+              state: "FAILED",
+              startedAt: "2023-07-21T17:32:28Z",
+              elapsedTime: "23",
+              avgProcessingTimePerMinute: "1",
+            }
+          ]
+
+    StatusFailedForKind:
+      value:
+        replayId: "1000"
+        operation: "reindex"
+        totalRecords: 2
+        processedRecords: 1
+        startedAt: 2023-07-21T17:32:28Z
+        state: "FAILED"
+        filter: {"kinds":["osdu:wks:reference-data--VelocityAnalysisMethod:1.0.0"]}
+        status:
+          [
+            {
+              kind: "osdu:wks:reference-data--VelocityAnalysisMethod:1.0.0",
+              totalRecords: 2,
+              processedRecords: 1,
+              state: "FAILED",
+              startedAt: "2023-07-21T17:32:28Z",
+              elapsedTime: "23",
+              avgProcessingTimePerMinute: "1",
+            }
+          ]
+    StatusPassedForKind:
+      value:
+        replayId: "1000"
+        operation: "reindex"
+        totalRecordsOverall: 2
+        processedRecordsOverall: 1
+        startedAt: 2023-07-21T17:32:28Z
+        OverallState: IN_PROGRESS
+        filter: {"kinds":["osdu:wks:reference-data--VelocityAnalysisMethod:1.0.0"]}
+        status:
+          [
+            {
+              kind: "osdu:wks:reference-data--VelocityAnalysisMethod:1.0.0",
+              totalRecords: 2,
+              processedRecords: 1,
+              state: "IN_PROGRESS",
+              startedAt: "2023-07-21T17:32:28Z",
+              elapsedTime: "23",
+              avgProcessingTimePerMinute: "1",
+            }
+          ]
   securitySchemes:
     Authorization:
       type: http
diff --git a/docs/docs/api.md b/docs/docs/api.md
index afeb5676066b453c7754d6360d827a774d80652c..e2881fd20ec1faa92d844541bdf15a8f20a02a28 100644
--- a/docs/docs/api.md
+++ b/docs/docs/api.md
@@ -835,3 +835,68 @@ properties:
 
 ## Using Storage APIs in the Collaboration context
 Query, Records and Patch API can also be used in the [Collaboration context](CollaborationContext.md)
+
+## Replay
+### Get Replay Status
+This API returns replay status.
+```
+GET /api/storage/v2/replay/status/{replayId}
+```
+
+<details><summary>curl</summary>
+
+```
+
+curl --request GET \
+  --url '/api/storage/v2/replay/status/{replayId}' \
+  --header 'Authorization: Bearer <JWT>' \
+  --header 'Content-Type: application/json' \
+  --header 'data-partition-id: common'
+  
+
+
+```
+</details>
+
+### Replay 
+This API provides a replay ID that enables tracking of the replay operation's status. It's utilized to initiate the replay operation, which reindexes records according to the request type. Presently, two operation values are accepted: "replay" and "reindex." The replay operation utilizes the default service bus, the "recordtopic," while the reindex operation utilizes the "reindex" topic. Currently replay all or replay of single kind is supported.
+```
+POST /api/storage/v2/replay
+
+To reindex all the records
+<details><summary>curl</summary>
+
+```
+curl --request POST \
+  --url  '/api/storage/v2/replay' \
+  --header 'Authorization: Bearer <JWT>' \
+  --header 'Content-Type: application/json' \
+  --header 'data-partition-id: common' \
+  --data '{
+  "operation": "replay"
+}'
+
+```
+</details>
+
+To reindex single kind.
+
+<details><summary>curl</summary>
+
+```
+curl --request POST \
+   --url '/api/storage/v2/replay' \
+   --header 'Authorization: Bearer <JWT>' \
+   --header 'Content-Type: application/json' \
+   --header 'data-partition-id: common' \
+   --data '{
+   "operation": "replay",
+   "filter": {
+   "kinds": [
+   "osdu:wks:reference-data--VelocityAnalysisMethod:1.0.0"
+   ]
+   }
+}'
+
+```
+</details>
diff --git a/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/MessageBusImpl.java b/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/MessageBusImpl.java
index 433c77f93d951f47576ed0dba17203701ac4d71e..5c2ac3fdfe286ae39ec55a7ee31b30de435e7c46 100644
--- a/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/MessageBusImpl.java
+++ b/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/MessageBusImpl.java
@@ -15,6 +15,7 @@
 package org.opengroup.osdu.storage.provider.aws;
 
 import com.amazonaws.services.sns.model.PublishRequest;
+import org.apache.commons.lang3.NotImplementedException;
 import org.opengroup.osdu.core.aws.ssm.K8sLocalParameterProvider;
 import com.amazonaws.services.sns.AmazonSNS;
 import org.opengroup.osdu.core.aws.ssm.K8sParameterNotFoundException;
@@ -32,7 +33,10 @@ import org.springframework.stereotype.Component;
 
 import jakarta.annotation.PostConstruct;
 import jakarta.inject.Inject;
+
 import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 
 @Component
@@ -62,7 +66,7 @@ public class MessageBusImpl implements IMessageBus {
         PublishRequestBuilder<PubSubInfo> publishRequestBuilder = new PublishRequestBuilder<>();
         publishRequestBuilder.setGeneralParametersFromHeaders(headers);
         logger.info("Storage publishes message " + headers.getCorrelationId());
-        for (int i =0; i < messages.length; i+= BATCH_SIZE){
+        for (int i = 0; i < messages.length; i += BATCH_SIZE) {
 
             PubSubInfo[] batch = Arrays.copyOfRange(messages, i, Math.min(messages.length, i + BATCH_SIZE));
 
@@ -76,4 +80,14 @@ public class MessageBusImpl implements IMessageBus {
     public void publishMessage(Optional<CollaborationContext> collaborationContext, DpsHeaders headers, RecordChangedV2... messages) {
         // To be implemented by aws provider
     }
+
+    @Override
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, List<?> messageList) {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, PubSubInfo... messages) {
+        throw new NotImplementedException();
+    }
 }
diff --git a/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/QueryRepositoryImpl.java b/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/QueryRepositoryImpl.java
index abb6703452615eb281663f4a41b04954e557588a..888fd3ad7a9594fdb0a6b6a21554203ed1a127f3 100644
--- a/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/QueryRepositoryImpl.java
+++ b/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/QueryRepositoryImpl.java
@@ -15,6 +15,7 @@
 package org.opengroup.osdu.storage.provider.aws;
 
 import com.amazonaws.services.dynamodbv2.model.ComparisonOperator;
+import org.apache.commons.lang3.NotImplementedException;
 import org.apache.http.HttpStatus;
 import org.opengroup.osdu.core.aws.dynamodb.DynamoDBQueryHelperFactory;
 import org.opengroup.osdu.core.aws.dynamodb.DynamoDBQueryHelperV2;
@@ -23,6 +24,9 @@ import org.opengroup.osdu.core.common.model.http.AppException;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.DatastoreQueryResult;
+import org.opengroup.osdu.storage.model.RecordId;
+import org.opengroup.osdu.storage.model.RecordIdAndKind;
+import org.opengroup.osdu.storage.model.RecordInfoQueryResult;
 import org.opengroup.osdu.storage.provider.aws.util.dynamodb.RecordMetadataDoc;
 import org.opengroup.osdu.storage.provider.aws.util.dynamodb.SchemaDoc;
 import org.opengroup.osdu.storage.provider.interfaces.IQueryRepository;
@@ -144,4 +148,24 @@ public class QueryRepositoryImpl implements IQueryRepository {
         dqr.setResults(ids);
         return dqr;
     }
+
+    @Override
+    public RecordInfoQueryResult<RecordIdAndKind> getAllRecordIdAndKind(Integer limit, String cursor) {
+        return null;
+    }
+
+    @Override
+    public RecordInfoQueryResult<RecordId> getAllRecordIdsFromKind(Integer limit, String cursor, String kind) {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public HashMap<String, Long> getActiveRecordsCount() {
+        throw new  NotImplementedException();
+    }
+
+    @Override
+    public Map<String, Long> getActiveRecordsCountForKinds(List<String> kinds) {
+        throw new  NotImplementedException();
+    }
 }
diff --git a/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/mongo/MongoDbQueryRepository.java b/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/mongo/MongoDbQueryRepository.java
index caf31e868925354bd0918d42aeae9009c648ef26..b741cf8d86757b7793095372612ae5f494789905 100644
--- a/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/mongo/MongoDbQueryRepository.java
+++ b/provider/storage-aws/src/main/java/org/opengroup/osdu/storage/provider/aws/mongo/MongoDbQueryRepository.java
@@ -15,11 +15,15 @@
 
 package org.opengroup.osdu.storage.provider.aws.mongo;
 
+import org.apache.commons.lang3.NotImplementedException;
 import org.opengroup.osdu.core.aws.mongodb.MongoDBMultiClusterFactory;
 import org.opengroup.osdu.core.aws.mongodb.entity.QueryPageResult;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.DatastoreQueryResult;
+import org.opengroup.osdu.storage.model.RecordId;
+import org.opengroup.osdu.storage.model.RecordIdAndKind;
+import org.opengroup.osdu.storage.model.RecordInfoQueryResult;
 import org.opengroup.osdu.storage.provider.aws.mongo.dto.RecordMetadataMongoDBDto;
 import org.opengroup.osdu.storage.provider.interfaces.IQueryRepository;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
@@ -28,6 +32,9 @@ import org.springframework.data.mongodb.core.query.Query;
 import org.springframework.stereotype.Repository;
 
 import jakarta.inject.Inject;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import java.util.stream.Collectors;
 
@@ -94,6 +101,26 @@ public class MongoDbQueryRepository implements IQueryRepository {
         return dqr;
     }
 
+    @Override
+    public RecordInfoQueryResult<RecordIdAndKind> getAllRecordIdAndKind(Integer limit, String cursor) {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public RecordInfoQueryResult<RecordId> getAllRecordIdsFromKind(Integer limit, String cursor, String kind) {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public HashMap<String, Long> getActiveRecordsCount() {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public Map<String, Long> getActiveRecordsCountForKinds(List<String> kinds) {
+        throw new NotImplementedException();
+    }
+
     private String getCollection(String dataPartitionId) {
         indexUpdater.checkIndex(dataPartitionId);
         return RECORD_METADATA_PREFIX + dataPartitionId;
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/MessageBusImpl.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/MessageBusImpl.java
index 069b488b1312720e3b94cd4606bfc19c6dc732b4..933353f512c71e1bde41bc680e72423f36a84bed 100644
--- a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/MessageBusImpl.java
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/MessageBusImpl.java
@@ -14,8 +14,13 @@
 
 package org.opengroup.osdu.storage.provider.azure;
 
+import com.google.gson.Gson;
+import com.microsoft.azure.servicebus.ITopicClient;
+import com.microsoft.azure.servicebus.Message;
+import com.microsoft.azure.servicebus.MessageBody;
 import org.opengroup.osdu.azure.publisherFacade.MessagePublisher;
 import org.opengroup.osdu.azure.publisherFacade.PublisherInfo;
+import org.opengroup.osdu.azure.servicebus.ITopicClientFactory;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.PubSubInfo;
@@ -24,27 +29,49 @@ import org.opengroup.osdu.storage.provider.azure.di.EventGridConfig;
 import org.opengroup.osdu.storage.provider.azure.di.ServiceBusConfig;
 import org.opengroup.osdu.storage.provider.azure.di.PublisherConfig;
 import org.opengroup.osdu.storage.provider.interfaces.IMessageBus;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.stereotype.Component;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+
 
 @Component
 public class MessageBusImpl implements IMessageBus {
+
+    private final static Logger LOGGER = LoggerFactory.getLogger(MessageBusImpl.class);
+
     @Autowired
-    private ServiceBusConfig serviceBusConfig;
+    ServiceBusConfig serviceBusConfig;
+
     @Autowired
     private EventGridConfig eventGridConfig;
+
     @Autowired
     private MessagePublisher messagePublisher;
+
     @Autowired
     private PublisherConfig publisherConfig;
+
+    @Autowired
+    private ITopicClientFactory topicClientFactory;
+
+    private final static Logger logger = LoggerFactory.getLogger(MessageBusImpl.class);
+
+    private final static String ROUTING_KEY = "topic";
+
     @Override
     public void publishMessage(DpsHeaders headers, PubSubInfo... messages) {
 
         // The batch size is same for both Event grid and Service bus.
         final int BATCH_SIZE = Integer.parseInt(publisherConfig.getPubSubBatchSize());
-        for(int i = 0; i < messages.length; i += BATCH_SIZE) {
+        for (int i = 0; i < messages.length; i += BATCH_SIZE) {
+            logger.info(String.format("The correlation id for this is %s",headers.getCorrelationId()));
             PubSubInfo[] batch = Arrays.copyOfRange(messages, i, Math.min(messages.length, i + BATCH_SIZE));
             PublisherInfo publisherInfo = getPartialPublisherInfo();
             publisherInfo.setBatch(batch);
@@ -53,12 +80,54 @@ public class MessageBusImpl implements IMessageBus {
         }
     }
 
+    @Override
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, PubSubInfo... messages) {
+
+        int messageSequenceTracker = 0;
+        // The batch size is same for both Event grid and Service bus.
+        final int BATCH_SIZE = Integer.parseInt(routingInfo.get("publisherBatchSize"));
+        for (int i = 0; i < messages.length; i += BATCH_SIZE) {
+            DpsHeaders dpsHeaders = this.addMessageTracingToDpsHeaders(headers,messageSequenceTracker);
+            PubSubInfo[] batch = Arrays.copyOfRange(messages, i, Math.min(messages.length, i + BATCH_SIZE));
+            PublisherInfo publisherInfo = getPartialPublisherInfo();
+            publisherInfo.setBatch(batch);
+            publisherInfo.setServiceBusTopicName(routingInfo.get(ROUTING_KEY));
+            publisherInfo.setMessageId(dpsHeaders.getCorrelationId());
+            logger.info("Publishing messages with correlation ID: {} to the topic: {}",dpsHeaders.getCorrelationId(),routingInfo.get(ROUTING_KEY));
+            messagePublisher.publishMessage(dpsHeaders, publisherInfo, Optional.empty());
+            messageSequenceTracker++;
+        }
+    }
+
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, List<?> messageList) {
 
+        List<Message> messageBatch = new ArrayList<>();
+        for (Object messageObject : messageList) {
+            Message message = new Message();
+            String json = new Gson().toJson(messageObject);
+            message.setMessageBody(MessageBody.fromValueData(json));
+            message.setCorrelationId(headers.getCorrelationId());
+            message.setContentType("application/json");
+            messageBatch.add(message);
+        }
+        ITopicClient client;
+        try {
+            client = topicClientFactory.getClient(headers.getPartitionId(), routingInfo.get(ROUTING_KEY));
+            client.sendBatch(messageBatch);
+        } catch (Exception e) {
+            logger.info( "The following exception occurred during the publish message event {}",
+                    e.getMessage());
+            throw new RuntimeException("Some exception occurred during the publish message event.", e);
+        }
+    }
+
+    @Override
     public void publishMessage(Optional<CollaborationContext> collaborationContext, DpsHeaders headers, RecordChangedV2... messages) {
+
         // The batch size is same for both Event grid and Service bus.
         final int BATCH_SIZE = Integer.parseInt(publisherConfig.getPubSubBatchSize());
         for (int i = 0; i < messages.length; i += BATCH_SIZE) {
-            String messageId = String.format("%s-%d",headers.getCorrelationId(), i);
+            String messageId = String.format("%s-%d", headers.getCorrelationId(), i);
             RecordChangedV2[] batch = Arrays.copyOfRange(messages, i, Math.min(messages.length, i + BATCH_SIZE));
             PublisherInfo publisherInfo = getPartialPublisherInfo();
             publisherInfo.setBatch(batch);
@@ -76,4 +145,12 @@ public class MessageBusImpl implements IMessageBus {
                 .eventGridEventDataVersion(eventGridConfig.getEventDataVersion())
                 .build();
     }
+
+    private DpsHeaders addMessageTracingToDpsHeaders(DpsHeaders headers, int messageSequenceTracker) {
+        String correlationId = headers.getCorrelationId() + "_" + messageSequenceTracker;
+        DpsHeaders dpsHeaders = new DpsHeaders();
+        dpsHeaders.put(DpsHeaders.CORRELATION_ID,correlationId);
+        dpsHeaders.put(DpsHeaders.DATA_PARTITION_ID,headers.getPartitionId());
+        return dpsHeaders;
+    }
 }
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/config/ThreadDpsHeaders.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/config/ThreadDpsHeaders.java
index dc3d405608964741262ff81a9d9cbd4838ac3c26..ca8ab6350e46096a30784dbf8483cd994bcac659 100644
--- a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/config/ThreadDpsHeaders.java
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/config/ThreadDpsHeaders.java
@@ -25,7 +25,6 @@ import java.util.HashMap;
 import java.util.Map;
 @Component
 @Primary
-@ConditionalOnProperty(value = "azure.feature.legaltag-compliance-update.enabled", havingValue = "true", matchIfMissing = false)
 @Scope(value = "ThreadScope", proxyMode = ScopedProxyMode.TARGET_CLASS)
 public class ThreadDpsHeaders extends DpsHeaders {
 
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/di/CosmosContainerConfig.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/di/CosmosContainerConfig.java
index 8922b7a3b84c6250b93d88eaf2ceba094cc0ce35..9cc7a7923e377407496c4c8793a8a19b2eaee428 100644
--- a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/di/CosmosContainerConfig.java
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/di/CosmosContainerConfig.java
@@ -1,10 +1,12 @@
 package org.opengroup.osdu.storage.provider.azure.di;
 
+import lombok.Data;
 import org.springframework.beans.factory.annotation.Value;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
 @Configuration
+@Data
 public class CosmosContainerConfig {
 
     @Value("${azure.cosmosdb.schema.collection}")
@@ -16,6 +18,9 @@ public class CosmosContainerConfig {
     @Value("${azure.cosmosdb.tenantinfo.collection}")
     private String tenantInfoCollection;
 
+    @Value("${azure.replay.collectionName}")
+    private String replayCollectionName;
+
     @Bean
     public String schemaCollection() {
         return schemaCollectionName;
@@ -30,5 +35,4 @@ public class CosmosContainerConfig {
     public String tenantInfoCollection() {
         return tenantInfoCollection;
     }
-
 }
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/di/ServiceBusConfig.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/di/ServiceBusConfig.java
index 345db458e595d91ec6c27e2d97b47cb6488b16bb..7cd5bc07291c3cf8be5022e05761493a99de507e 100644
--- a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/di/ServiceBusConfig.java
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/di/ServiceBusConfig.java
@@ -41,5 +41,4 @@ public class ServiceBusConfig {
 
     @Value("${azure.legal.servicebus.topic-subscription}")
     private String legalServiceBusTopicSubscription;
-
 }
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/model/RecordIdKindDoc.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/model/RecordIdKindDoc.java
new file mode 100644
index 0000000000000000000000000000000000000000..361bed7dba36b5114c4ec2021d2d67f05333a7e6
--- /dev/null
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/model/RecordIdKindDoc.java
@@ -0,0 +1,32 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.provider.azure.model;
+
+import com.azure.spring.data.cosmos.core.mapping.PartitionKey;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import org.springframework.data.annotation.Id;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+public class RecordIdKindDoc {
+    @PartitionKey
+    @Id
+    private String id;
+
+    private String kind;
+}
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/RecordMetadataDoc.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/model/RecordMetadataDoc.java
similarity index 94%
rename from provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/RecordMetadataDoc.java
rename to provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/model/RecordMetadataDoc.java
index f7a6a44404cf25215039009e799fb911d955cc89..4378ca9371887bd830f755ef233d5c6642a00a16 100644
--- a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/RecordMetadataDoc.java
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/model/RecordMetadataDoc.java
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package org.opengroup.osdu.storage.provider.azure;
+package org.opengroup.osdu.storage.provider.azure.model;
 
 import com.azure.spring.data.cosmos.core.mapping.PartitionKey;
 import lombok.AllArgsConstructor;
@@ -28,5 +28,6 @@ public class RecordMetadataDoc {
     @PartitionKey
     @Id
     private String id;
+
     private RecordMetadata metadata;
 }
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/model/ReplayMetaData.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/model/ReplayMetaData.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a17ab2a59d76be278522de456ad8146a87f9936
--- /dev/null
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/model/ReplayMetaData.java
@@ -0,0 +1,47 @@
+package org.opengroup.osdu.storage.provider.azure.model;
+
+import com.azure.spring.data.cosmos.core.mapping.PartitionKey;
+import com.fasterxml.jackson.annotation.JsonInclude;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import org.opengroup.osdu.storage.request.ReplayFilter;
+import org.springframework.data.annotation.Id;
+
+import java.util.Date;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+@Builder
+public class ReplayMetaData {
+
+    @Id
+    private String id;
+
+    @PartitionKey
+    private String replayId;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private String kind;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private String operation;
+
+    private Long totalRecords;
+
+    private Date startedAt;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private ReplayFilter filter;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private Long processedRecords;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private String state;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private String elapsedTime;
+}
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplayMessageHandler.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplayMessageHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..0a29d114e430c4f8988502887a1ac98696686ea3
--- /dev/null
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplayMessageHandler.java
@@ -0,0 +1,71 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.provider.azure.pubsub;
+
+import com.google.gson.Gson;
+import com.microsoft.azure.servicebus.IMessage;
+import org.opengroup.osdu.core.common.model.http.DpsHeaders;
+import org.opengroup.osdu.storage.dto.ReplayMessage;
+import org.opengroup.osdu.storage.provider.azure.config.ThreadDpsHeaders;
+import org.opengroup.osdu.storage.provider.azure.util.MDCContextMap;
+import org.opengroup.osdu.storage.service.replay.IReplayService;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.slf4j.MDC;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.stereotype.Component;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+@ConditionalOnProperty(value = "feature.replay.enabled", havingValue = "true", matchIfMissing = false)
+@Component
+public class ReplayMessageHandler {
+
+    private final static Logger LOGGER = LoggerFactory.getLogger(ReplayMessageHandler.class);
+
+    @Autowired
+    private IReplayService replayService;
+
+    @Autowired
+    private DpsHeaders headers;
+
+    @Autowired
+    private MDCContextMap mdcContextMap;
+
+    public void handle(IMessage message) {
+
+        ReplayMessage replayMessage = getReplayMessage(message);
+        headers.put(DpsHeaders.DATA_PARTITION_ID,replayMessage.getDataPartitionId());
+        headers.put(DpsHeaders.CORRELATION_ID,replayMessage.getCorrelationId());
+        MDC.setContextMap(mdcContextMap.getContextMap(headers.getCorrelationId(), headers.getPartitionId()));
+        LOGGER.info("Processing PerformReplayMessage with a delivery count of: {}", message.getDeliveryCount());
+        replayService.processReplayMessage(replayMessage);
+    }
+
+    public void handleFailure(IMessage message) {
+
+        LOGGER.info("Processing Failure for message");
+        ReplayMessage replayMessage = getReplayMessage(message);
+        replayService.processFailure(replayMessage);
+        LOGGER.info("Processed Failure for ReplayMessage");
+    }
+
+    private ReplayMessage getReplayMessage(IMessage message) {
+
+        String serviceBusMessageString = message.getMessageBody().getValueData().toString();
+        return new Gson().fromJson(serviceBusMessageString, ReplayMessage.class);
+    }
+}
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplaySubscriptionManager.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplaySubscriptionManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..4511e05fa7a7b26d40f9aff2ff837db41976695e
--- /dev/null
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplaySubscriptionManager.java
@@ -0,0 +1,94 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.provider.azure.pubsub;
+
+import com.microsoft.azure.servicebus.MessageHandlerOptions;
+import com.microsoft.azure.servicebus.SubscriptionClient;
+import com.microsoft.azure.servicebus.primitives.ServiceBusException;
+import org.opengroup.osdu.azure.servicebus.ISubscriptionClientFactory;
+import org.opengroup.osdu.core.common.model.tenant.TenantInfo;
+import org.opengroup.osdu.core.common.provider.interfaces.ITenantFactory;
+import org.opengroup.osdu.storage.provider.azure.di.ServiceBusConfig;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.stereotype.Component;
+
+import java.time.Duration;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.stream.Collectors;
+
+@ConditionalOnProperty(value = "feature.replay.enabled", havingValue = "true")
+@Component
+public class ReplaySubscriptionManager {
+
+    private final static Logger LOGGER = LoggerFactory.getLogger(ReplaySubscriptionManager.class);
+
+    @Autowired
+    private ServiceBusConfig serviceBusConfig;
+
+    @Autowired
+    private ITenantFactory tenantFactory;
+
+    @Autowired
+    private ReplayMessageHandler replayMessageHandler;
+
+    @Autowired
+    private ISubscriptionClientFactory subscriptionClientFactory;
+
+    @Value("#{${replay.routingProperties}}")
+    private Map<String, String> replayRoutingProperty;
+
+    public void subscribeToEvents() {
+
+        List<String> tenantList = tenantFactory.listTenantInfo().stream().map(TenantInfo::getDataPartitionId).
+                                               collect(Collectors.toList());
+
+        ExecutorService executorService = Executors
+                .newFixedThreadPool(Integer.parseUnsignedInt(serviceBusConfig.getSbExecutorThreadPoolSize()));
+
+        for (String partition : tenantList) {
+            try {
+                SubscriptionClient subscriptionClient =
+                        this.subscriptionClientFactory
+                                .getClient(partition, replayRoutingProperty.get("topic"), replayRoutingProperty.get("topicSubscription"));
+
+                registerMessageHandler(subscriptionClient, replayMessageHandler, executorService);
+            } catch (Exception e) {
+                LOGGER.error("Error while creating or registering replay topic subscription client {}", e.getMessage(), e);
+            }
+        }
+    }
+
+    private void registerMessageHandler(SubscriptionClient subscriptionClient, ReplayMessageHandler replayMessageHandler, ExecutorService executorService) throws ServiceBusException, InterruptedException {
+
+        ReplaySubscriptionMessageHandler messageHandler = new ReplaySubscriptionMessageHandler(subscriptionClient, replayMessageHandler);
+
+        subscriptionClient.registerMessageHandler(
+                messageHandler,
+                new MessageHandlerOptions(
+                        Integer.parseUnsignedInt(serviceBusConfig.getMaxConcurrentCalls()),
+                        false,
+                        Duration.ofSeconds(Integer.parseUnsignedInt(serviceBusConfig.getMaxLockRenewDurationInSeconds())),
+                        Duration.ofSeconds(1)
+                ),
+                executorService);
+    }
+}
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplaySubscriptionMessageHandler.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplaySubscriptionMessageHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5dda0198ca070f67b622748368610389369d55e
--- /dev/null
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplaySubscriptionMessageHandler.java
@@ -0,0 +1,63 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.provider.azure.pubsub;
+
+import com.microsoft.azure.servicebus.*;
+import lombok.SneakyThrows;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+
+import java.util.concurrent.CompletableFuture;
+
+@ConditionalOnProperty(value = "feature.replay.enabled", havingValue = "true", matchIfMissing = false)
+public class ReplaySubscriptionMessageHandler implements IMessageHandler {
+    private final static Logger LOGGER = LoggerFactory.getLogger(ReplaySubscriptionMessageHandler.class);
+
+    private final SubscriptionClient receiveClient;
+
+    private final int MAX_DELIVERY_COUNT = 3;
+
+    private ReplayMessageHandler replayMessageHandler;
+
+    public ReplaySubscriptionMessageHandler(SubscriptionClient subscriptionClient, ReplayMessageHandler replayMessageHandler) {
+        this.receiveClient = subscriptionClient;
+        this.replayMessageHandler = replayMessageHandler;
+    }
+
+    @SneakyThrows
+    @Override
+    public CompletableFuture<Void> onMessageAsync(IMessage message) {
+        try {
+            replayMessageHandler.handle(message);
+            return this.receiveClient.completeAsync(message.getLockToken());
+        } catch (Exception e) {
+            LOGGER.error("Exception while processing replay topic message.", e);
+            if (message.getDeliveryCount() >= MAX_DELIVERY_COUNT) {
+                LOGGER.error("Max Delivery Count of {} Exceeded for Message; Dead Lettering the message.", MAX_DELIVERY_COUNT, e);
+                replayMessageHandler.handleFailure(message);
+                return this.receiveClient.deadLetterAsync(message.getLockToken());
+            }
+            LOGGER.warn("Attempt {}/{} failed.", message.getDeliveryCount(), MAX_DELIVERY_COUNT, e);
+            return this.receiveClient.abandonAsync(message.getLockToken());
+        }
+    }
+
+    @Override
+    public void notifyException(Throwable throwable, ExceptionPhase exceptionPhase) {
+        
+        LOGGER.error("{} - {}", exceptionPhase, throwable.getMessage());
+    }
+}
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/repository/QueryRepository.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/repository/QueryRepository.java
index 36636d91460d323d40c69589abc2cb7aab92d6af..c563526dbb26f60dac28c25b02ab0c1002ea9d7e 100644
--- a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/repository/QueryRepository.java
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/repository/QueryRepository.java
@@ -14,15 +14,13 @@
 
 package org.opengroup.osdu.storage.provider.azure.repository;
 
+
 import com.azure.cosmos.CosmosException;
 import com.azure.cosmos.models.CosmosQueryRequestOptions;
+import com.azure.cosmos.models.SqlParameter;
 import com.azure.cosmos.models.SqlQuerySpec;
 import com.google.common.base.Strings;
-import com.lambdaworks.redis.RedisException;
-import net.bytebuddy.dynamic.DynamicType;
 import org.apache.http.HttpStatus;
-import org.jetbrains.annotations.Contract;
-import org.jetbrains.annotations.NotNull;
 import org.opengroup.osdu.azure.cosmosdb.CosmosStore;
 import org.opengroup.osdu.azure.query.CosmosStorePageRequest;
 import org.opengroup.osdu.core.common.cache.ICache;
@@ -32,23 +30,29 @@ import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.DatastoreQueryResult;
 import org.opengroup.osdu.core.common.model.storage.RecordState;
-import org.opengroup.osdu.core.common.util.Crc32c;
-import org.opengroup.osdu.storage.provider.azure.RecordMetadataDoc;
-import org.opengroup.osdu.storage.provider.azure.SchemaDoc;
+import org.opengroup.osdu.storage.model.RecordId;
+import org.opengroup.osdu.storage.model.RecordIdAndKind;
+import org.opengroup.osdu.storage.model.RecordInfoQueryResult;
+import org.opengroup.osdu.storage.provider.azure.model.RecordMetadataDoc;
 import org.opengroup.osdu.storage.provider.interfaces.IQueryRepository;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.beans.factory.annotation.Qualifier;
 import org.springframework.data.domain.Page;
-import org.opengroup.osdu.azure.query.CosmosStorePageRequest;
 import org.springframework.data.domain.Pageable;
-import org.springframework.data.domain.Sort;
 import org.springframework.stereotype.Repository;
 import org.springframework.util.Assert;
 
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 
+import static com.azure.cosmos.implementation.Utils.decodeBase64String;
+import static com.azure.cosmos.implementation.Utils.encodeBase64String;
+
 @Repository
 public class QueryRepository implements IQueryRepository {
 
@@ -61,8 +65,7 @@ public class QueryRepository implements IQueryRepository {
     @Autowired
     private SchemaRepository schema;
 
-    @Autowired
-    private JaxRsDpsLog logger;
+    private  static final Logger logger = LoggerFactory.getLogger(QueryRepository.class);
 
     @Autowired
     @Qualifier("CursorCache")
@@ -88,7 +91,7 @@ public class QueryRepository implements IQueryRepository {
                     for (int i = 0; i < limit && i < allDocs.size(); i++) {
                         docs.add(allDocs.get(i));
                     }
-                    String continuationToken = "start" + Integer.toString(limit);
+                    String continuationToken = "start" + limit;
                     cursorCache.put(continuationToken, Integer.toString(limit));
                     dqr.setCursor(continuationToken);
                 } else {
@@ -98,7 +101,7 @@ public class QueryRepository implements IQueryRepository {
                         docs.add(allDocs.get(i));
                     }
                     if (endIndex < allDocs.size()) {
-                        String continuationToken = "start" + Integer.toString(endIndex) + Integer.toString(limit);
+                        String continuationToken = "start" + endIndex + limit;
                         cursorCache.put(continuationToken, Integer.toString(endIndex));
                         dqr.setCursor(continuationToken);
                     }
@@ -118,7 +121,6 @@ public class QueryRepository implements IQueryRepository {
     @Override
     public DatastoreQueryResult getAllRecordIdsFromKind(String kind, Integer limit, String cursor, Optional<CollaborationContext> collaborationContext) {
         Assert.notNull(kind, "kind must not be null");
-
         boolean paginated = false;
         int numRecords = PAGE_SIZE;
         if (limit != null) {
@@ -179,6 +181,103 @@ public class QueryRepository implements IQueryRepository {
         }
 
         return dqr;
+
+    }
+
+
+    @Override
+    public RecordInfoQueryResult<RecordIdAndKind> getAllRecordIdAndKind(Integer limit, String cursor) {
+        return getQueryResult(getIdsAndKindBy_MetadataStatusQuery(RecordState.active.toString()), limit,cursor, RecordIdAndKind.class);
+    }
+
+    @Override
+    public RecordInfoQueryResult<RecordId> getAllRecordIdsFromKind(Integer limit, String cursor, String kind) {
+        return getQueryResult(getIdsBy_Kind_And_MetadataStatusQuery(kind, RecordState.active.toString()), limit, cursor, RecordId.class);
+    }
+
+    @Override
+    public HashMap<String, Long> getActiveRecordsCount() {
+        List<HashMap>  countByActiveRecordList = this.queryItemCount(getRecordCountBy_MetadataStatusQuery(RecordState.active.toString()));
+        return new HashMap<String, Long>() {{
+            put("*", (Long) countByActiveRecordList.get(0).get("$1"));
+        }};
+    }
+
+    @Override
+    public Map<String, Long> getActiveRecordsCountForKinds(List<String> kinds) {
+        List<HashMap> countByKindList = this.queryItemCount(getRecordCountBy_Kinds_MetadataStatusQuery(kinds, RecordState.active.toString()));
+        return countByKindList.stream()
+                .collect(HashMap::new,
+                        (map, m) -> map.put(m.get("kind").toString(), (Long) m.get("IdCount")),
+                        HashMap::putAll);
+    }
+
+    private List<HashMap> queryItemCount(SqlQuerySpec query) {
+        return this.cosmosStore.queryItems(dpsHeaders.getPartitionId(), cosmosDBName, storageRecordContainer, query, new CosmosQueryRequestOptions(), HashMap.class);
+    }
+
+    public <T> RecordInfoQueryResult<T> getQueryResult(SqlQuerySpec query, Integer limit, String cursor, Class<T> clazz) {
+        boolean paginated = false;
+        int numRecords = PAGE_SIZE;
+
+        if (limit != null) {
+            numRecords = limit > 0 ? limit : PAGE_SIZE;
+            paginated = true;
+        }
+
+        if (cursor != null && !cursor.isEmpty()) {
+            paginated = true;
+        }
+
+        RecordInfoQueryResult<T> recordQueryResult = new RecordInfoQueryResult<T>();
+        recordQueryResult.setResults(new ArrayList<>());
+        List<T> docs;
+        String continuation = (cursor == null) ? null : decodeBase64String(cursor);
+        int iteration = 1;
+        int preferredPageSize;
+        String encodedCursor = null;
+
+        try {
+            if (paginated) {
+                do {
+                    preferredPageSize = numRecords - recordQueryResult.getResults().size();
+                    Page<T> docPage = cosmosStore.queryItemsPage(dpsHeaders.getPartitionId(), cosmosDBName, storageRecordContainer, query, clazz, preferredPageSize, continuation);
+
+                    // Fetch records and set ids
+                    docs = docPage.getContent();
+                    docs.forEach(x -> recordQueryResult.getResults().add(x));
+
+                    if (iteration > 1) {
+                        // cosmosDb did not return the preferredPageSize in previous iteration, so it was queried again.
+                        this.logger.info(String.format("Iteration count of query on cosmosDb: %d, page size returned: %d, remaining page size: %d", iteration, docPage.getContent().size(), numRecords - recordQueryResult.getResults().size()));
+                    }
+
+                    // set continuationToken by fetching it from the response
+                    continuation = null;
+                    Pageable pageable = docPage.getPageable();
+                    if (pageable instanceof CosmosStorePageRequest) {
+                        continuation = ((CosmosStorePageRequest) pageable).getRequestContinuation();
+                    }
+                    iteration++;
+                } while (!Strings.isNullOrEmpty(continuation) && recordQueryResult.getResults().size() < numRecords);
+
+                     if(!Strings.isNullOrEmpty(continuation))
+                         encodedCursor = encodeBase64String(continuation.getBytes());
+
+                    recordQueryResult.setCursor(encodedCursor);
+            } else {
+                docs = cosmosStore.queryItems(dpsHeaders.getPartitionId(), cosmosDBName, storageRecordContainer, query, new CosmosQueryRequestOptions(), clazz);
+                recordQueryResult.setResults(docs);
+            }
+        } catch (CosmosException e) {
+            if (e.getStatusCode() == HttpStatus.SC_BAD_REQUEST && e.getMessage().contains("INVALID JSON in continuation token"))
+                throw this.getInvalidCursorException();
+            else throw e;
+        } catch (Exception e) {
+            throw e;
+        }
+
+        return recordQueryResult;
     }
 
     private List<String> getDistinctKind() {
@@ -190,6 +289,51 @@ public class QueryRepository implements IQueryRepository {
         return docs;
     }
 
+    private static SqlQuerySpec getIdsAndKindBy_MetadataStatusQuery(String status) {
+        SqlQuerySpec query = new SqlQuerySpec("SELECT c.id, c.metadata.kind FROM c WHERE c.metadata.status = @status");
+        List<SqlParameter> pars = query.getParameters();
+        pars.add(new SqlParameter("@status", status));
+        return query;
+    }
+
+    private static SqlQuerySpec getRecordCountBy_MetadataStatusQuery(String status) {
+        SqlQuerySpec query = new SqlQuerySpec("SELECT count(c.id) FROM c WHERE c.metadata.status = @status");
+        List<SqlParameter> pars = query.getParameters();
+        pars.add(new SqlParameter("@status", status));
+        return query;
+    }
+
+    private static SqlQuerySpec getRecordCountBy_Kinds_MetadataStatusQuery(List<String> kinds, String status) {
+        SqlQuerySpec query = new SqlQuerySpec(
+                "SELECT c.metadata.kind, COUNT(c.id) AS IdCount " +
+                        "FROM c " +
+                        "WHERE ARRAY_CONTAINS(@kinds, c.metadata.kind, true) AND c.metadata.status = @status " +
+                        "GROUP BY c.metadata.kind"
+        );
+
+        List<SqlParameter> pars = query.getParameters();
+        pars.add(new SqlParameter("@status", status));
+        pars.add(new SqlParameter("@kinds", kinds));
+
+        return query;
+    }
+
+
+    private static SqlQuerySpec getIdsBy_Kind_And_MetadataStatusQuery(String kind, String status) {
+        SqlQuerySpec query = new SqlQuerySpec(
+                "SELECT c.id " +
+                        "FROM c " +
+                        "WHERE c.metadata.kind = @kind AND c.metadata.status = @status"
+        );
+
+        List<SqlParameter> pars = query.getParameters();
+        pars.add(new SqlParameter("@kind", kind));
+        pars.add(new SqlParameter("@status", status));
+
+        return query;
+    }
+
+
     private AppException getInvalidCursorException() {
         return new AppException(HttpStatus.SC_BAD_REQUEST, "Cursor invalid", "The requested cursor does not exist or is invalid");
     }
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/repository/RecordMetadataRepository.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/repository/RecordMetadataRepository.java
index c46116d98bb9af9d186258a4a0ea002576dbc034..37b1a65d0860577841f20ace7a222882c4b41de1 100644
--- a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/repository/RecordMetadataRepository.java
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/repository/RecordMetadataRepository.java
@@ -15,6 +15,7 @@
 package org.opengroup.osdu.storage.provider.azure.repository;
 
 
+
 import com.azure.cosmos.CosmosException;
 import com.azure.cosmos.models.CosmosPatchOperations;
 import com.azure.cosmos.models.CosmosQueryRequestOptions;
@@ -32,7 +33,7 @@ import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.legal.LegalCompliance;
 import org.opengroup.osdu.core.common.model.storage.RecordMetadata;
-import org.opengroup.osdu.storage.provider.azure.RecordMetadataDoc;
+import org.opengroup.osdu.storage.provider.azure.model.RecordMetadataDoc;
 import org.opengroup.osdu.storage.provider.azure.di.AzureBootstrapConfig;
 import org.opengroup.osdu.storage.provider.azure.di.CosmosContainerConfig;
 import org.opengroup.osdu.storage.provider.azure.model.DocumentCount;
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/repository/ReplayRepository.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/repository/ReplayRepository.java
new file mode 100644
index 0000000000000000000000000000000000000000..f184e4a69572491edbc761e21c7329f466ef32cb
--- /dev/null
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/repository/ReplayRepository.java
@@ -0,0 +1,137 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.provider.azure.repository;
+
+import com.azure.cosmos.models.CosmosQueryRequestOptions;
+import com.azure.cosmos.models.SqlParameter;
+import com.azure.cosmos.models.SqlQuerySpec;
+import org.opengroup.osdu.core.common.model.http.DpsHeaders;
+import org.opengroup.osdu.storage.dto.ReplayMetaDataDTO;
+import org.opengroup.osdu.storage.provider.azure.di.AzureBootstrapConfig;
+import org.opengroup.osdu.storage.provider.azure.di.CosmosContainerConfig;
+import org.opengroup.osdu.storage.provider.azure.model.ReplayMetaData;
+import org.opengroup.osdu.storage.provider.interfaces.IReplayRepository;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Repository;
+import org.springframework.util.CollectionUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@Repository
+public class ReplayRepository extends SimpleCosmosStoreRepository<ReplayMetaData> implements IReplayRepository {
+
+    @Autowired
+    private DpsHeaders headers;
+
+    @Autowired
+    private CosmosContainerConfig cosmosContainerConfig;
+
+    @Autowired
+    private AzureBootstrapConfig azureBootstrapConfig;
+
+    public ReplayRepository() {
+        super(ReplayMetaData.class);
+    }
+
+
+    @Override
+    public List<ReplayMetaDataDTO> getReplayStatusByReplayId(String replayId) {
+
+        SqlQuerySpec query = new SqlQuerySpec("SELECT * FROM c WHERE c.replayId= @replayId");
+        List<SqlParameter> pars = query.getParameters();
+        pars.add(new SqlParameter("@replayId", replayId));
+        CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();
+
+        List<ReplayMetaData> queryResults = this.queryItems(headers.getPartitionId(),
+                azureBootstrapConfig.getCosmosDBName(),
+                cosmosContainerConfig.getReplayCollectionName(),
+                query,
+                options);
+        List<ReplayMetaDataDTO> replayMetaDataDTOList = new ArrayList<>();
+        for (ReplayMetaData replayMetaData : queryResults) {
+            replayMetaDataDTOList.add(this.getReplayMetaDataDTOObject(replayMetaData));
+        }
+        return replayMetaDataDTOList;
+    }
+
+    public ReplayMetaDataDTO getReplayStatusByKindAndReplayId(String kind, String replayId) {
+
+        SqlQuerySpec query = new SqlQuerySpec("SELECT * FROM c WHERE c.replayId= @replayId and c.kind= @kind");
+        List<SqlParameter> pars = query.getParameters();
+        pars.add(new SqlParameter("@replayId", replayId));
+        pars.add(new SqlParameter("@kind", kind));
+        CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();
+
+        List<ReplayMetaData> queryResults = this.queryItems(headers.getPartitionId(),
+                azureBootstrapConfig.getCosmosDBName(),
+                cosmosContainerConfig.getReplayCollectionName(),
+                query,
+                options);
+        ReplayMetaData replayMetaData = CollectionUtils.isEmpty(queryResults) ? null : queryResults.get(0);
+        return this.getReplayMetaDataDTOObject(replayMetaData);
+
+    }
+
+    @Override
+    public ReplayMetaDataDTO save(ReplayMetaDataDTO replayMetaDataDTO) {
+
+        ReplayMetaData entity = getReplayMetaData(replayMetaDataDTO);
+        ReplayMetaData replayMetaData = this.save(
+                entity,
+                headers.getPartitionId(),
+                azureBootstrapConfig.getCosmosDBName(),
+                cosmosContainerConfig.getReplayCollectionName(),
+                entity.getReplayId()
+        );
+        return this.getReplayMetaDataDTOObject(replayMetaData);
+    }
+
+    private ReplayMetaDataDTO getReplayMetaDataDTOObject(ReplayMetaData replayMetaData) {
+
+        if (replayMetaData == null) return null;
+
+        return ReplayMetaDataDTO.builder()
+                .id(replayMetaData.getId())
+                .replayId(replayMetaData.getReplayId())
+                .totalRecords(replayMetaData.getTotalRecords())
+                .processedRecords(replayMetaData.getProcessedRecords())
+                .operation(replayMetaData.getOperation())
+                .state(replayMetaData.getState())
+                .elapsedTime(replayMetaData.getElapsedTime())
+                .filter(replayMetaData.getFilter())
+                .startedAt(replayMetaData.getStartedAt())
+                .kind(replayMetaData.getKind())
+                .build();
+    }
+
+    private ReplayMetaData getReplayMetaData(ReplayMetaDataDTO replayMetaDataDTO) {
+
+        if (replayMetaDataDTO == null) return null;
+
+        return ReplayMetaData.builder()
+                .id(replayMetaDataDTO.getId())
+                .replayId(replayMetaDataDTO.getReplayId())
+                .totalRecords(replayMetaDataDTO.getTotalRecords())
+                .processedRecords(replayMetaDataDTO.getProcessedRecords())
+                .operation(replayMetaDataDTO.getOperation())
+                .state(replayMetaDataDTO.getState())
+                .elapsedTime(replayMetaDataDTO.getElapsedTime())
+                .filter(replayMetaDataDTO.getFilter())
+                .startedAt(replayMetaDataDTO.getStartedAt())
+                .kind(replayMetaDataDTO.getKind())
+                .build();
+    }
+}
diff --git a/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/util/ReplaySubscriberSetup.java b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/util/ReplaySubscriberSetup.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a828127a8e1171a224deefa7d0b1f327b25a6cb
--- /dev/null
+++ b/provider/storage-azure/src/main/java/org/opengroup/osdu/storage/provider/azure/util/ReplaySubscriberSetup.java
@@ -0,0 +1,51 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.provider.azure.util;
+
+import org.jetbrains.annotations.NotNull;
+import org.opengroup.osdu.storage.provider.azure.config.ThreadScopeBeanFactoryPostProcessor;
+import org.opengroup.osdu.storage.provider.azure.pubsub.ReplaySubscriptionManager;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.context.ApplicationListener;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.event.ContextRefreshedEvent;
+import org.springframework.stereotype.Component;
+
+@ConditionalOnProperty(value = "feature.replay.enabled", havingValue = "true", matchIfMissing = false)
+@Component
+public class ReplaySubscriberSetup implements ApplicationListener<ContextRefreshedEvent> {
+
+    @Value("${feature.replay.enabled}")
+    private Boolean setup;
+
+    @Autowired
+    private ReplaySubscriptionManager replaySubscriptionManager;
+
+    @Bean
+    public static BeanFactoryPostProcessor beanFactoryPostProcessor1() {
+        return new ThreadScopeBeanFactoryPostProcessor();
+    }
+
+    @Override
+    public void onApplicationEvent(@NotNull ContextRefreshedEvent contextRefreshedEvent) {
+        if(setup) {
+            replaySubscriptionManager.subscribeToEvents();
+        }
+    }
+}
+
diff --git a/provider/storage-azure/src/main/resources/application.properties b/provider/storage-azure/src/main/resources/application.properties
index 12fe0bb806200748950d290e0533e1835022624b..ab10532779c003f690da4805ed9c9b7a6c7e0299 100644
--- a/provider/storage-azure/src/main/resources/application.properties
+++ b/provider/storage-azure/src/main/resources/application.properties
@@ -1,4 +1,4 @@
-#  Copyright � Microsoft Corporation
+#  Copyright ? Microsoft Corporation
 #
 #  Licensed under the Apache License, Version 2.0 (the "License");
 #  you may not use this file except in compliance with the License.
@@ -128,4 +128,14 @@ featureFlag.strategy=dataPartition
 collaborationFilter.excludedPaths=info,liveness_check,swagger,swagger-ui/swagger-ui.css,swagger-ui/swagger-ui-standalone-preset.js,api-docs,api-docs.yaml,api-docs/swagger-config
 
 # To enable the full server path url in OpenAPI Swagger
-api.server.fullUrl.enabled=${swaggerFullUrlEnabled:true}
\ No newline at end of file
+api.server.fullUrl.enabled=${swaggerFullUrlEnabled:true}
+
+# Replay Feature Config
+feature.replay.enabled=true
+azure.replay.collectionName=ReplayStatus
+
+replay.operation.routingProperties = { reindex : { topic : 'reindextopic', queryBatchSize : '5000',publisherBatchSize : '50'} , \
+                     replay: { topic : 'recordstopic', queryBatchSize : '5000', publisherBatchSize : '50'}\
+                   }
+
+replay.routingProperties = { topic : 'replaytopic', topicSubscription : 'replaytopicsubscription'}
diff --git a/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplayMessageHandlerTest.java b/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplayMessageHandlerTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..bee7bd5ee55d25ae8d49a3e3d8bd05028ccca189
--- /dev/null
+++ b/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplayMessageHandlerTest.java
@@ -0,0 +1,57 @@
+package org.opengroup.osdu.storage.provider.azure.pubsub;
+
+import com.google.gson.Gson;
+import com.microsoft.azure.servicebus.Message;
+import com.microsoft.azure.servicebus.MessageBody;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.opengroup.osdu.core.common.model.http.DpsHeaders;
+import org.opengroup.osdu.storage.dto.ReplayMessage;
+import org.opengroup.osdu.storage.provider.azure.util.MDCContextMap;
+import org.opengroup.osdu.storage.service.replay.IReplayService;
+
+import java.util.HashMap;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@ExtendWith(MockitoExtension.class)
+public class ReplayMessageHandlerTest {
+
+    @InjectMocks
+    private ReplayMessageHandler replayMessageHandler;
+
+    @Mock
+    private IReplayService replayService;
+
+    @Mock
+    private DpsHeaders dpsHeaders;
+
+    @Mock
+    private MDCContextMap mdcContextMap;
+
+    private ReplayMessage replayMessage = ReplayMessage.builder().headers(new HashMap<>()).build();
+
+    @Test
+    public void shouldInvokeProcessReplayMessage() {
+
+        when(mdcContextMap.getContextMap(any(), any())).thenReturn(new HashMap<>());
+        Message message = new Message();
+        message.setMessageBody(MessageBody.fromValueData(new Gson().toJson(replayMessage)));
+        replayMessageHandler.handle(message);
+        verify(replayService, times(1)).processReplayMessage(any());
+    }
+
+    @Test
+    public void shouldInvokeProcessFailure() {
+
+        Message message = new Message();
+        message.setMessageBody(MessageBody.fromValueData(new Gson().toJson(replayMessage)));
+        replayMessageHandler.handleFailure(message);
+        verify(replayService, times(1)).processFailure(any());
+    }
+}
diff --git a/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplaySubscriptionManagerHandlerTest.java b/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplaySubscriptionManagerHandlerTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb8a8fc544cae5324ef509bd41fac2f73b9e533d
--- /dev/null
+++ b/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/pubsub/ReplaySubscriptionManagerHandlerTest.java
@@ -0,0 +1,48 @@
+package org.opengroup.osdu.storage.provider.azure.pubsub;
+
+
+import com.microsoft.azure.servicebus.Message;
+import com.microsoft.azure.servicebus.SubscriptionClient;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
+
+import java.util.UUID;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@ExtendWith(MockitoExtension.class)
+public class ReplaySubscriptionManagerHandlerTest {
+
+    private static final UUID uuid = UUID.randomUUID();
+
+    @InjectMocks
+    private ReplaySubscriptionMessageHandler replaySubscriptionMessageHandler;
+    @Mock
+    private ReplayMessageHandler replayMessageHandler;
+
+    @Mock
+    private SubscriptionClient subscriptionClient;
+
+    @Mock
+    private Message message;
+
+    @BeforeEach
+    void init() {
+        when(message.getLockToken()).thenReturn(uuid);
+    }
+
+    @Test
+    void shouldInvokeAbandonAsync() throws Exception {
+
+        doThrow(new RuntimeException()).when(replayMessageHandler).handle(message);
+        replaySubscriptionMessageHandler.onMessageAsync(message);
+        verify(subscriptionClient, times(1)).abandonAsync(uuid);
+        verify(replayMessageHandler, times(1)).handle(message);
+    }
+}
diff --git a/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/repository/QueryRepositoryTest.java b/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/repository/QueryRepositoryTest.java
index f33ab5e4ad3e2b618020d80153652ba602c4621d..4dc51d9dbb6e71ca9971d234e4dc19f37f83ea61 100644
--- a/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/repository/QueryRepositoryTest.java
+++ b/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/repository/QueryRepositoryTest.java
@@ -18,7 +18,11 @@ import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.DatastoreQueryResult;
 import org.opengroup.osdu.core.common.model.storage.RecordMetadata;
-import org.opengroup.osdu.storage.provider.azure.RecordMetadataDoc;
+import org.opengroup.osdu.core.common.model.storage.RecordState;
+import org.opengroup.osdu.storage.model.RecordId;
+import org.opengroup.osdu.storage.model.RecordIdAndKind;
+import org.opengroup.osdu.storage.model.RecordInfoQueryResult;
+import org.opengroup.osdu.storage.provider.azure.model.RecordMetadataDoc;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.Pageable;
 import org.springframework.test.util.ReflectionTestUtils;
@@ -282,4 +286,31 @@ class QueryRepositoryTest {
         return recordMetadata;
     }
 
+    @Test
+    public void getActiveRecordsCount() {
+
+        Long activeRecordCount = 50L;
+        HashMap hashMap = new HashMap();
+        hashMap.put("$1",50L);
+        when(cosmosStore.queryItems(any(),any(),any(),any(),any(),any())).thenReturn(Collections.singletonList(hashMap));
+        Map<String, Long>  countByKind = queryRepository.getActiveRecordsCount();
+        verify(cosmosStore,times(1)).queryItems(eq(dpsHeaders.getPartitionId()), eq(cosmosDBName), eq(storageContainer),any(),any(), eq(HashMap.class));
+        assertEquals(activeRecordCount,countByKind.get("*"));
+    }
+
+    @Test
+    public void getActiveRecordsCountForKinds() {
+        Long activeRecordCountByKind = 50L;
+        List<String> kindList = new ArrayList<>();
+        kindList.add(KIND1);
+        kindList.add(KIND2);
+        HashMap<Object, Object> result = new HashMap<>();
+        result.put("kind", KIND1);
+        result.put("IdCount", 50L);
+        when(cosmosStore.queryItems(any(),any(),any(),any(),any(),any())).thenReturn(Collections.singletonList(result));
+        Map<String, Long>  countByKind = queryRepository.getActiveRecordsCountForKinds(kindList);
+        verify(cosmosStore,times(1)).queryItems(eq(dpsHeaders.getPartitionId()), eq(cosmosDBName), eq(storageContainer),any(),any(), eq(HashMap.class));
+        assertEquals(activeRecordCountByKind, countByKind.get(KIND1));
+    }
+
 }
diff --git a/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/repository/RecordMetadataRepositoryTest.java b/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/repository/RecordMetadataRepositoryTest.java
index 0365f953a1f0c90c4d585e7b0f4b9ab625186483..2587471dc3cada93942c502ffd8077e63ee8a27b 100644
--- a/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/repository/RecordMetadataRepositoryTest.java
+++ b/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/repository/RecordMetadataRepositoryTest.java
@@ -26,8 +26,8 @@ import org.opengroup.osdu.core.common.model.http.AppException;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.RecordMetadata;
-import org.opengroup.osdu.storage.provider.azure.RecordMetadataDoc;
 import org.opengroup.osdu.storage.provider.azure.model.DocumentCount;
+import org.opengroup.osdu.storage.provider.azure.model.RecordMetadataDoc;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.PageRequest;
 import org.springframework.data.domain.Pageable;
@@ -51,16 +51,21 @@ class RecordMetadataRepositoryTest {
     private final static String KIND = "opendes:source:type:1.0.0";
     private final static String STATUS = "active";
     private final ObjectMapper mapper = new ObjectMapper();
+
     @Rule
     ExpectedException exceptionRule = ExpectedException.none();
     @Mock
     private JaxRsDpsLog logger;
+
     @Mock
     private CosmosStoreBulkOperations cosmosBulkStore;
+
     @Mock
     private DpsHeaders headers;
+
     @Mock
     private Page<RecordMetadataDoc> page;
+
     @Mock
     private CosmosStore cosmosStore;
     @InjectMocks
@@ -167,7 +172,7 @@ class RecordMetadataRepositoryTest {
     }
 
     @Test
-    void shouldReturnErrors_whenPatchFailsWithAppExceptionWithoutCollaborationContext() throws IOException {
+    public void shouldReturnErrors_whenPatchFailsWithAppExceptionWithoutCollaborationContext() throws IOException {
         RecordMetadata recordMetadata = createRecord(RECORD_ID1);
         Map<RecordMetadata, JsonPatch> jsonPatchPerRecord = new HashMap<>();
         jsonPatchPerRecord.put(recordMetadata, getJsonPatchFromJsonString(getValidInputJsonForPatch()));
@@ -231,7 +236,7 @@ class RecordMetadataRepositoryTest {
         doThrow(appException).when(cosmosBulkStore).bulkMultiPatchWithCosmosClient(eq("opendes"), eq("osdu-db"), eq("collection"), anyMap(), eq(partitionKeyForDoc), eq(1));
         Optional<CollaborationContext> context = Optional.empty();
         try {
-            recordMetadataRepository.patch(jsonPatchPerRecord, context);
+            recordMetadataRepository.patch(jsonPatchPerRecord, Optional.empty());
             fail("expected exception");
         } catch (AppException e) {
 
diff --git a/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/repository/ReplayRepositoryTest.java b/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/repository/ReplayRepositoryTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..e1e408d47a7d71c2ee00c5bf099de2920b8182d9
--- /dev/null
+++ b/provider/storage-azure/src/test/java/org/opengroup/osdu/storage/provider/azure/repository/ReplayRepositoryTest.java
@@ -0,0 +1,93 @@
+package org.opengroup.osdu.storage.provider.azure.repository;
+
+import com.azure.cosmos.models.CosmosQueryRequestOptions;
+import com.azure.cosmos.models.SqlQuerySpec;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.opengroup.osdu.core.common.model.http.DpsHeaders;
+import org.opengroup.osdu.storage.dto.ReplayMetaDataDTO;
+import org.opengroup.osdu.storage.provider.azure.di.AzureBootstrapConfig;
+import org.opengroup.osdu.storage.provider.azure.di.CosmosContainerConfig;
+import org.opengroup.osdu.azure.cosmosdb.CosmosStore;
+
+import java.util.List;
+import java.util.UUID;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.verify;
+
+@ExtendWith(MockitoExtension.class)
+public class ReplayRepositoryTest {
+
+    @Mock(lenient = true)
+    private DpsHeaders dpsHeaders;
+
+    @Mock
+    private CosmosContainerConfig cosmosContainerConfig;
+
+    @Mock
+    private AzureBootstrapConfig azureBootstrapConfig;
+
+    @Mock
+    private CosmosStore cosmosStore;
+
+    @InjectMocks
+    ReplayRepository replayRepository;
+
+    private final String REPLAY_ID = UUID.randomUUID().toString();
+
+    private final static String KIND = "opendes:source:type:1.0.0";
+
+    @BeforeEach
+    public void setUp() {
+        when(dpsHeaders.getPartitionId()).thenReturn("opendes");
+    }
+
+    @Test
+    void getReplayStatusByReplayId()
+    {
+        when(azureBootstrapConfig.getCosmosDBName()).thenReturn("osdu-db");
+        when(cosmosContainerConfig.getReplayCollectionName()).thenReturn("ReplayStatus");
+        List<ReplayMetaDataDTO> replayMetaDataDTOList = replayRepository.getReplayStatusByReplayId(REPLAY_ID);
+        verify(cosmosStore).queryItems(
+                eq("opendes"),
+                eq("osdu-db"),
+                eq("ReplayStatus"),
+                any(SqlQuerySpec.class),
+                any(CosmosQueryRequestOptions.class),
+                any()
+        );
+        assertEquals(0, replayMetaDataDTOList.size());
+    }
+
+    @Test
+    void getReplayStatusByKindAndReplayId(){
+
+        when(azureBootstrapConfig.getCosmosDBName()).thenReturn("osdu-db");
+        when(cosmosContainerConfig.getReplayCollectionName()).thenReturn("ReplayStatus");
+        replayRepository.getReplayStatusByKindAndReplayId(KIND, REPLAY_ID);
+        verify(cosmosStore).queryItems(
+                eq("opendes"),
+                eq("osdu-db"),
+                eq("ReplayStatus"),
+                any(SqlQuerySpec.class),
+                any(CosmosQueryRequestOptions.class),
+                any());
+    }
+
+    @Test
+    void save() {
+
+        ReplayMetaDataDTO replayMetaData = new ReplayMetaDataDTO();
+        replayMetaData.setReplayId(REPLAY_ID);
+        ReplayMetaDataDTO replayMetaDataDTO= replayRepository.save(replayMetaData);
+        assertEquals(REPLAY_ID,replayMetaDataDTO.getReplayId());
+    }
+}
diff --git a/provider/storage-gc/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/pubsub/OqmPubSub.java b/provider/storage-gc/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/pubsub/OqmPubSub.java
index 6d11d434f84846d39ac92f4fa832a4d678f982e1..687d239fa5d9ce91b2b2a6228f1d1be519e3278e 100644
--- a/provider/storage-gc/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/pubsub/OqmPubSub.java
+++ b/provider/storage-gc/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/pubsub/OqmPubSub.java
@@ -19,6 +19,7 @@ package org.opengroup.osdu.storage.provider.gcp.web.pubsub;
 
 import com.google.gson.Gson;
 import lombok.RequiredArgsConstructor;
+import org.apache.commons.lang3.NotImplementedException;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.PubSubInfo;
@@ -35,6 +36,7 @@ import org.springframework.stereotype.Repository;
 import jakarta.annotation.PostConstruct;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 
@@ -80,6 +82,16 @@ public class OqmPubSub implements IMessageBus {
 
     @Override
     public void publishMessage(Optional<CollaborationContext> collaborationContext, DpsHeaders headers, RecordChangedV2... messages) {
-        //TODO: to be implemented by gcp provider
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, List<?> messageList) {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, PubSubInfo... messages) {
+        throw new NotImplementedException();
     }
 }
diff --git a/provider/storage-gc/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/repository/OsmQueryRepository.java b/provider/storage-gc/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/repository/OsmQueryRepository.java
index bd60f4af74688e497cc4e56fecbb9c5b9562d8fe..ce427114e3d7fc636021cd3b546e19e6b47ddb38 100644
--- a/provider/storage-gc/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/repository/OsmQueryRepository.java
+++ b/provider/storage-gc/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/repository/OsmQueryRepository.java
@@ -25,11 +25,14 @@ import static org.opengroup.osdu.storage.provider.gcp.web.repository.OsmRecordsM
 import static org.springframework.beans.factory.config.BeanDefinition.SCOPE_SINGLETON;
 
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import java.util.stream.Collectors;
 import lombok.RequiredArgsConstructor;
 import lombok.extern.java.Log;
+import org.apache.commons.lang3.NotImplementedException;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.storage.DatastoreQueryResult;
 import org.opengroup.osdu.core.common.model.storage.RecordMetadata;
@@ -42,6 +45,9 @@ import org.opengroup.osdu.core.gcp.osm.model.query.GetQuery;
 import org.opengroup.osdu.core.gcp.osm.service.Context;
 import org.opengroup.osdu.core.gcp.osm.translate.Outcome;
 import org.opengroup.osdu.core.gcp.osm.translate.ViewResult;
+import org.opengroup.osdu.storage.model.RecordId;
+import org.opengroup.osdu.storage.model.RecordIdAndKind;
+import org.opengroup.osdu.storage.model.RecordInfoQueryResult;
 import org.opengroup.osdu.storage.provider.interfaces.IQueryRepository;
 import org.springframework.context.annotation.Scope;
 import org.springframework.stereotype.Repository;
@@ -73,6 +79,26 @@ public class OsmQueryRepository implements IQueryRepository {
         return new DatastoreQueryResult(out.getPointer(), out.getList().stream().map(e -> (String) e.get("id")).collect(Collectors.toList()));
     }
 
+    @Override
+    public RecordInfoQueryResult<RecordIdAndKind> getAllRecordIdAndKind(Integer limit, String cursor) {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public RecordInfoQueryResult<RecordId> getAllRecordIdsFromKind(Integer limit, String cursor, String kind) {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public HashMap<String, Long> getActiveRecordsCount() {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public Map<String, Long> getActiveRecordsCountForKinds(List<String> kinds) {
+        throw new NotImplementedException();
+    }
+
     private int getLimitTuned(Integer limit) {
         return limit == null ? PAGE_SIZE : (limit > 0 ? limit : PAGE_SIZE);
     }
diff --git a/provider/storage-gc/src/test/java/org/opengroup/osdu/storage/provider/gcp/messaging/jobs/stub/OqmPubSubStub.java b/provider/storage-gc/src/test/java/org/opengroup/osdu/storage/provider/gcp/messaging/jobs/stub/OqmPubSubStub.java
index acd86722cb4cb29186559e3b466aacfac61c0d7f..40f3c8b8bd7b4740db07575aafb5c7aa42aaea19 100644
--- a/provider/storage-gc/src/test/java/org/opengroup/osdu/storage/provider/gcp/messaging/jobs/stub/OqmPubSubStub.java
+++ b/provider/storage-gc/src/test/java/org/opengroup/osdu/storage/provider/gcp/messaging/jobs/stub/OqmPubSubStub.java
@@ -24,6 +24,7 @@ import java.util.Map;
 import java.util.Optional;
 
 import lombok.Getter;
+import org.apache.commons.lang3.NotImplementedException;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.PubSubInfo;
@@ -42,6 +43,16 @@ public class OqmPubSubStub implements IMessageBus {
 
     @Override
     public void publishMessage(Optional<CollaborationContext> collaborationContext, DpsHeaders headers, RecordChangedV2... messages) {
-        //TODO: to be implemented by gcp provider
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, List<?> messageList) {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, PubSubInfo... messages) {
+        throw new NotImplementedException();
     }
 }
diff --git a/provider/storage-ibm/src/main/java/org/opengroup/osdu/storage/provider/ibm/MessageBusImpl.java b/provider/storage-ibm/src/main/java/org/opengroup/osdu/storage/provider/ibm/MessageBusImpl.java
index 41ef0a457342b26daf566e48a0b3157ef43efd13..10b9f48c95d817948ff45fa7f6febd4369bd746e 100644
--- a/provider/storage-ibm/src/main/java/org/opengroup/osdu/storage/provider/ibm/MessageBusImpl.java
+++ b/provider/storage-ibm/src/main/java/org/opengroup/osdu/storage/provider/ibm/MessageBusImpl.java
@@ -5,11 +5,13 @@ package org.opengroup.osdu.storage.provider.ibm;
 
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 
 import jakarta.inject.Inject;
 
+import org.apache.commons.lang3.NotImplementedException;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.PubSubInfo;
@@ -49,7 +51,17 @@ public class MessageBusImpl implements IMessageBus {
 
 	@Override
 	public void publishMessage(Optional<CollaborationContext> collaborationContext, DpsHeaders headers, RecordChangedV2... messages) {
-		//TODO: to be implemented by ibm provider
+		throw new  NotImplementedException();
+	}
+
+	@Override
+	public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, List<?> messageList) {
+		throw new  NotImplementedException();
+	}
+
+	@Override
+	public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, PubSubInfo... messages) {
+		throw new NotImplementedException();
 	}
 
 }
diff --git a/provider/storage-ibm/src/main/java/org/opengroup/osdu/storage/provider/ibm/QueryRepositoryImpl.java b/provider/storage-ibm/src/main/java/org/opengroup/osdu/storage/provider/ibm/QueryRepositoryImpl.java
index 457ff795044b47c09f00d19711361b25f523867b..b3ea94f7d3ab43805acc8081f79fc24e690199f2 100644
--- a/provider/storage-ibm/src/main/java/org/opengroup/osdu/storage/provider/ibm/QueryRepositoryImpl.java
+++ b/provider/storage-ibm/src/main/java/org/opengroup/osdu/storage/provider/ibm/QueryRepositoryImpl.java
@@ -9,12 +9,15 @@ import static com.cloudant.client.api.query.Operation.and;
 
 import java.net.MalformedURLException;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 
 import jakarta.annotation.PostConstruct;
 import jakarta.inject.Inject;
 
+import org.apache.commons.lang3.NotImplementedException;
 import org.apache.http.HttpStatus;
 import org.opengroup.osdu.core.common.model.http.AppException;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
@@ -23,6 +26,9 @@ import org.opengroup.osdu.core.common.model.storage.RecordState;
 import org.opengroup.osdu.core.common.model.tenant.TenantInfo;
 import org.opengroup.osdu.core.ibm.auth.ServiceCredentials;
 import org.opengroup.osdu.core.ibm.cloudant.IBMCloudantClientFactory;
+import org.opengroup.osdu.storage.model.RecordId;
+import org.opengroup.osdu.storage.model.RecordIdAndKind;
+import org.opengroup.osdu.storage.model.RecordInfoQueryResult;
 import org.opengroup.osdu.storage.provider.interfaces.IQueryRepository;
 import org.springframework.beans.factory.annotation.Value;
 import org.springframework.stereotype.Repository;
@@ -142,7 +148,27 @@ public class QueryRepositoryImpl implements IQueryRepository {
         
         return result;
     }
-	
+
+	@Override
+	public RecordInfoQueryResult<RecordIdAndKind> getAllRecordIdAndKind(Integer limit, String cursor) {
+		throw new NotImplementedException();
+	}
+
+	@Override
+	public RecordInfoQueryResult<RecordId> getAllRecordIdsFromKind(Integer limit, String cursor, String kind) {
+		throw new  NotImplementedException();
+	}
+
+	@Override
+	public HashMap<String, Long> getActiveRecordsCount() {
+		throw new  NotImplementedException();
+	}
+
+	@Override
+	public Map<String, Long> getActiveRecordsCountForKinds(List<String> kinds) {
+		throw new  NotImplementedException();
+	}
+
 	public static String validateCursor(String cursor, Database db) {
     	if (cursor != null && !cursor.isEmpty()) {
     		if (db.contains(cursor)) {
diff --git a/storage-core-plus/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/pubsub/OqmPubSub.java b/storage-core-plus/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/pubsub/OqmPubSub.java
index 26c33d66af1cf6954b1b648bfc4a6088b362cded..4d32321585e91a3d9831602d19f5f1a67e57fd55 100644
--- a/storage-core-plus/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/pubsub/OqmPubSub.java
+++ b/storage-core-plus/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/pubsub/OqmPubSub.java
@@ -19,6 +19,7 @@ package org.opengroup.osdu.storage.provider.gcp.web.pubsub;
 
 import com.google.gson.Gson;
 import lombok.RequiredArgsConstructor;
+import org.apache.commons.lang3.NotImplementedException;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.PubSubInfo;
@@ -36,6 +37,7 @@ import org.springframework.stereotype.Repository;
 import jakarta.annotation.PostConstruct;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 
@@ -81,6 +83,16 @@ public class OqmPubSub implements IMessageBus {
 
     @Override
     public void publishMessage(Optional<CollaborationContext> collaborationContext, DpsHeaders headers, RecordChangedV2... messages) {
-        //TODO: to be implemented by gcp provider
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, List<?> messageList) {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, PubSubInfo... messages) {
+        throw new NotImplementedException();
     }
 }
diff --git a/storage-core-plus/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/repository/OsmQueryRepository.java b/storage-core-plus/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/repository/OsmQueryRepository.java
index b616eb8f539f440ed9db174c2e6602d5b979a5a8..89f3fbe870a8ff3e7092bb17527155eed10602e1 100644
--- a/storage-core-plus/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/repository/OsmQueryRepository.java
+++ b/storage-core-plus/src/main/java/org/opengroup/osdu/storage/provider/gcp/web/repository/OsmQueryRepository.java
@@ -26,11 +26,14 @@ import static org.opengroup.osdu.storage.provider.gcp.web.repository.OsmRecordsM
 import static org.springframework.beans.factory.config.BeanDefinition.SCOPE_SINGLETON;
 
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import java.util.stream.Collectors;
 import lombok.RequiredArgsConstructor;
 import lombok.extern.java.Log;
+import org.apache.commons.lang3.NotImplementedException;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.storage.DatastoreQueryResult;
 import org.opengroup.osdu.core.common.model.storage.RecordMetadata;
@@ -44,6 +47,9 @@ import org.opengroup.osdu.core.osm.core.model.query.GetQuery;
 import org.opengroup.osdu.core.osm.core.service.Context;
 import org.opengroup.osdu.core.osm.core.translate.Outcome;
 import org.opengroup.osdu.core.osm.core.translate.ViewResult;
+import org.opengroup.osdu.storage.model.RecordId;
+import org.opengroup.osdu.storage.model.RecordIdAndKind;
+import org.opengroup.osdu.storage.model.RecordInfoQueryResult;
 import org.opengroup.osdu.storage.provider.interfaces.IQueryRepository;
 import org.springframework.context.annotation.Scope;
 import org.springframework.stereotype.Repository;
@@ -75,6 +81,26 @@ public class OsmQueryRepository implements IQueryRepository {
         return new DatastoreQueryResult(out.getPointer(), out.getList().stream().map(e -> (String) e.get("id")).collect(Collectors.toList()));
     }
 
+    @Override
+    public RecordInfoQueryResult<RecordIdAndKind> getAllRecordIdAndKind(Integer limit, String cursor) {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public RecordInfoQueryResult<RecordId> getAllRecordIdsFromKind(Integer limit, String cursor, String kind) {
+        throw new  NotImplementedException();
+    }
+
+    @Override
+    public HashMap<String, Long> getActiveRecordsCount() {
+        throw new  NotImplementedException();
+    }
+
+    @Override
+    public Map<String, Long> getActiveRecordsCountForKinds(List<String> kinds) {
+        throw new  NotImplementedException();
+    }
+
     private int getLimitTuned(Integer limit) {
         return limit == null ? PAGE_SIZE : (limit > 0 ? limit : PAGE_SIZE);
     }
diff --git a/storage-core-plus/src/test/java/org/opengroup/osdu/storage/provider/gcp/messaging/jobs/stub/OqmPubSubStub.java b/storage-core-plus/src/test/java/org/opengroup/osdu/storage/provider/gcp/messaging/jobs/stub/OqmPubSubStub.java
index acd86722cb4cb29186559e3b466aacfac61c0d7f..40f3c8b8bd7b4740db07575aafb5c7aa42aaea19 100644
--- a/storage-core-plus/src/test/java/org/opengroup/osdu/storage/provider/gcp/messaging/jobs/stub/OqmPubSubStub.java
+++ b/storage-core-plus/src/test/java/org/opengroup/osdu/storage/provider/gcp/messaging/jobs/stub/OqmPubSubStub.java
@@ -24,6 +24,7 @@ import java.util.Map;
 import java.util.Optional;
 
 import lombok.Getter;
+import org.apache.commons.lang3.NotImplementedException;
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.PubSubInfo;
@@ -42,6 +43,16 @@ public class OqmPubSubStub implements IMessageBus {
 
     @Override
     public void publishMessage(Optional<CollaborationContext> collaborationContext, DpsHeaders headers, RecordChangedV2... messages) {
-        //TODO: to be implemented by gcp provider
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, List<?> messageList) {
+        throw new NotImplementedException();
+    }
+
+    @Override
+    public void publishMessage(DpsHeaders headers, Map<String, String> routingInfo, PubSubInfo... messages) {
+        throw new NotImplementedException();
     }
 }
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/api/ReplayApi.java b/storage-core/src/main/java/org/opengroup/osdu/storage/api/ReplayApi.java
new file mode 100644
index 0000000000000000000000000000000000000000..2267e90b372f6775ad07a314eb5792e29eebf196
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/api/ReplayApi.java
@@ -0,0 +1,107 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.api;
+
+import io.swagger.v3.oas.annotations.Operation;
+import io.swagger.v3.oas.annotations.Parameter;
+import io.swagger.v3.oas.annotations.media.Content;
+import io.swagger.v3.oas.annotations.media.Schema;
+import io.swagger.v3.oas.annotations.responses.ApiResponse;
+import io.swagger.v3.oas.annotations.responses.ApiResponses;
+import io.swagger.v3.oas.annotations.security.SecurityRequirement;
+import jakarta.validation.Valid;
+import org.opengroup.osdu.core.common.http.CollaborationContextFactory;
+import org.opengroup.osdu.core.common.model.http.AppError;
+import org.opengroup.osdu.core.common.model.http.AppException;
+import org.opengroup.osdu.core.common.model.http.CollaborationContext;
+import org.opengroup.osdu.core.common.model.validation.ValidateCollaborationContext;
+import org.opengroup.osdu.storage.request.ReplayRequest;
+import org.opengroup.osdu.storage.response.ReplayStatusResponse;
+import org.opengroup.osdu.storage.response.ReplayResponse;
+import org.opengroup.osdu.storage.service.replay.ReplayService;
+import org.opengroup.osdu.storage.util.Role;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.MediaType;
+import org.springframework.http.ResponseEntity;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.validation.annotation.Validated;
+import org.springframework.web.bind.annotation.*;
+import org.springframework.web.context.annotation.RequestScope;
+
+import java.util.Optional;
+import java.util.UUID;
+
+@ConditionalOnProperty(value = "feature.replay.enabled", havingValue = "true", matchIfMissing = false)
+@RestController
+@RequestMapping("replay")
+@RequestScope
+@Validated
+public class ReplayApi {
+
+    @Autowired
+    private ReplayService replayService;
+
+    @Autowired
+    private CollaborationContextFactory collaborationContextFactory;
+
+    @Operation(summary = "${replayApi.getReplayStatus.summary}", description = "${replayApi.getReplayStatus.description}",
+            security = {@SecurityRequirement(name = "Authorization")}, tags = {"replay"})
+    @ApiResponses(value = {
+            @ApiResponse(responseCode = "200", description = "Status of the replay", content = {@Content(schema = @Schema(implementation = ReplayStatusResponse.class))}),
+            @ApiResponse(responseCode = "400", description = "Bad Request", content = {@Content(schema = @Schema(implementation = AppError.class))}),
+            @ApiResponse(responseCode = "401", description = "Unauthorized", content = {@Content(schema = @Schema(implementation = AppError.class))}),
+            @ApiResponse(responseCode = "403", description = "Forbidden", content = {@Content(schema = @Schema(implementation = AppError.class))}),
+            @ApiResponse(responseCode = "500", description = "Internal Server Error", content = {@Content(schema = @Schema(implementation = AppError.class))}),
+            @ApiResponse(responseCode = "502", description = "Bad Gateway", content = {@Content(schema = @Schema(implementation = AppError.class))}),
+            @ApiResponse(responseCode = "503", description = "Service Unavailable", content = {@Content(schema = @Schema(implementation = AppError.class))})
+    })
+    @GetMapping(value = "/status/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
+    @PreAuthorize("@authorizationFilter.hasRole('" + Role.USER_OPS + "')")
+    public ResponseEntity<ReplayStatusResponse> getReplayStatus(@PathVariable("id") String id) {
+
+        return new ResponseEntity<>(replayService.getReplayStatus(id), HttpStatus.OK);
+    }
+
+    @Operation(summary = "${replayApi.triggerReplay.summary}", description = "${replayApi.triggerReplay.description}",
+            security = {@SecurityRequirement(name = "Authorization")}, tags = {"replay"})
+    @ApiResponses(value = {
+            @ApiResponse(responseCode = "202", description = "Replay request is accepted", content = {@Content(schema = @Schema(implementation = ReplayResponse.class))}),
+            @ApiResponse(responseCode = "400", description = "Bad Request", content = {@Content(schema = @Schema(implementation = AppError.class))}),
+            @ApiResponse(responseCode = "401", description = "Unauthorized", content = {@Content(schema = @Schema(implementation = AppError.class))}),
+            @ApiResponse(responseCode = "403", description = "Forbidden", content = {@Content(schema = @Schema(implementation = AppError.class))}),
+            @ApiResponse(responseCode = "500", description = "Internal Server Error", content = {@Content(schema = @Schema(implementation = AppError.class))}),
+            @ApiResponse(responseCode = "502", description = "Bad Gateway", content = {@Content(schema = @Schema(implementation = AppError.class))}),
+            @ApiResponse(responseCode = "503", description = "Service Unavailable", content = {@Content(schema = @Schema(implementation = AppError.class))})
+    })
+    @PostMapping(produces = MediaType.APPLICATION_JSON_VALUE)
+    @PreAuthorize("@authorizationFilter.hasRole('" + Role.USER_OPS + "')")
+    public ResponseEntity<ReplayResponse> triggerReplay(@Parameter(description = "x-collaboration") @RequestHeader(name = "x-collaboration", required = false)
+                                                        @jakarta.validation.Valid @ValidateCollaborationContext String collaborationDirectives,
+                                                        @Valid @RequestBody ReplayRequest replayRequest) {
+
+        Optional<CollaborationContext> collaborationContext = collaborationContextFactory.create(collaborationDirectives);
+        if (collaborationContext.isPresent())
+            throw new AppException(
+                    org.apache.http.HttpStatus.SC_NOT_IMPLEMENTED,
+                    "Collaboration feature not implemented for Replay API.",
+                    "Collaboration feature is not yet supported for the Replay API.");
+
+        replayRequest.setReplayId(UUID.randomUUID().toString());
+        ReplayResponse response = replayService.handleReplayRequest(replayRequest);
+        return new ResponseEntity<>(response, HttpStatus.ACCEPTED);
+    }
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayData.java b/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayData.java
new file mode 100644
index 0000000000000000000000000000000000000000..812e4476a19d533fd402f7dc75fff55dbe18f469
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayData.java
@@ -0,0 +1,46 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.dto;
+
+
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+@Builder
+public class ReplayData {
+
+    private String id;
+
+    private String operation;
+
+    private String replayType;
+
+    private String replayId;
+
+    private String kind;
+
+    private String cursor;
+
+    private Long completionCount;
+
+    private Long totalCount;
+
+    private Long startAtTimestamp;
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayMessage.java b/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayMessage.java
new file mode 100644
index 0000000000000000000000000000000000000000..6523fdac11bf78470e0340a498262cb0eeb844de
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayMessage.java
@@ -0,0 +1,52 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.dto;
+
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import org.opengroup.osdu.core.common.model.http.DpsHeaders;
+import org.opengroup.osdu.storage.enums.ReplayType;
+
+import java.util.HashMap;
+import java.util.Map;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+@Builder
+public class ReplayMessage {
+
+    private Map<String, String> headers =  new HashMap<>();
+
+    private ReplayData body;
+
+    public String getDataPartitionId(){
+        return getHeader(DpsHeaders.DATA_PARTITION_ID);
+    }
+
+    public void setDataPartitionId(String value){
+        headers.put(DpsHeaders.DATA_PARTITION_ID, value);
+    }
+
+    public String getCorrelationId(){
+        return getHeader(DpsHeaders.CORRELATION_ID);
+    }
+
+    private String getHeader(String header){
+        return headers == null? null : headers.get(header);
+    }
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayMetaDataDTO.java b/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayMetaDataDTO.java
new file mode 100644
index 0000000000000000000000000000000000000000..5be5b21185f7bf823f9be87bb3c6369215df1edd
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayMetaDataDTO.java
@@ -0,0 +1,58 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.dto;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import org.opengroup.osdu.storage.request.ReplayFilter;
+
+import java.util.Date;
+
+
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+public class ReplayMetaDataDTO {
+
+    private String id;
+
+    private String replayId;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private String kind;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private String operation;
+
+    private Long totalRecords;
+
+    private Date startedAt;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private ReplayFilter filter;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private Long processedRecords;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private String state;
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    private String elapsedTime;
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayStatus.java b/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayStatus.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f1e547758cf2938ec81c10057257757fc7fc0b8
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/dto/ReplayStatus.java
@@ -0,0 +1,41 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.dto;
+
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.util.Date;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@Builder
+public class ReplayStatus {
+
+    private String kind;
+
+    private Long totalRecords;
+
+    private Long processedRecords;
+
+    private String state;
+
+    private Date startedAt;
+
+    private String elapsedTime;
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/enums/ReplayOperation.java b/storage-core/src/main/java/org/opengroup/osdu/storage/enums/ReplayOperation.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c1d024f711fed8beece632e0230fa3609f77b38
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/enums/ReplayOperation.java
@@ -0,0 +1,41 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.enums;
+
+import lombok.Getter;
+
+import java.util.Arrays;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+@Getter
+public enum ReplayOperation {
+
+    REINDEX("reindex"),
+
+    REPLAY("replay");
+
+    private final String operation;
+
+    ReplayOperation(String operation) {
+        this.operation = operation;
+    }
+
+    public static Set<String> getValidReplayOperations() {
+        return Arrays.stream(values())
+                     .map(ReplayOperation::getOperation)
+                     .collect(Collectors.toSet());
+    }
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/enums/ReplayState.java b/storage-core/src/main/java/org/opengroup/osdu/storage/enums/ReplayState.java
new file mode 100644
index 0000000000000000000000000000000000000000..721920f28db63c55710afe3694d38d37d99c4866
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/enums/ReplayState.java
@@ -0,0 +1,25 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.enums;
+
+public enum ReplayState {
+    COMPLETED,
+
+    QUEUED,
+
+    IN_PROGRESS,
+
+    FAILED
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/enums/ReplayType.java b/storage-core/src/main/java/org/opengroup/osdu/storage/enums/ReplayType.java
new file mode 100644
index 0000000000000000000000000000000000000000..8add680dd5cd6099e05d691d27a7fdfdbd38f764
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/enums/ReplayType.java
@@ -0,0 +1,21 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.enums;
+
+public enum ReplayType {
+    REPLAY_KIND,
+
+    REPLAY_ALL
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/logging/StorageAuditEvents.java b/storage-core/src/main/java/org/opengroup/osdu/storage/logging/StorageAuditEvents.java
index 5691df6071aab06736c7ecab7a860e4d71079eed..f7dee0598af0ac6049806cad5a199d284f63a02d 100644
--- a/storage-core/src/main/java/org/opengroup/osdu/storage/logging/StorageAuditEvents.java
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/logging/StorageAuditEvents.java
@@ -18,9 +18,12 @@ import com.google.common.base.Strings;
 import org.opengroup.osdu.core.common.logging.audit.AuditAction;
 import org.opengroup.osdu.core.common.logging.audit.AuditPayload;
 import org.opengroup.osdu.core.common.logging.audit.AuditStatus;
+import org.opengroup.osdu.core.common.logging.audit.AuditAction;
 
 import java.util.List;
 
+import static java.util.Collections.singletonList;
+
 public class StorageAuditEvents {
     private static final String CREATE_OR_UPDATE_RECORD_ACTION_ID = "ST001";
     private static final String CREATE_OR_UPDATE_RECORD_MESSAGE = "Records created or updated";
@@ -55,6 +58,10 @@ public class StorageAuditEvents {
     private static final String READ_MULTIPLE_RECORDS_WITH_CONVERSION_MESSAGE = "Read multiple records with optional conversion";
 
     private static final String PURGE_RECORD_VERSIONS_ACTION_ID = "ST015";
+    private static final String CREATE_REPLAY_REQUEST = "ST015";
+
+    private static final String CREATE_REPLAY_REQUEST_MESSAGE = "Replay started";
+
     private final String user;
 
     public StorageAuditEvents(String user) {
@@ -319,4 +326,26 @@ public class StorageAuditEvents {
                 .user(user)
                 .build();
     }
+
+    public AuditPayload getCreateReplayRequestFail(List<String> resources) {
+        return AuditPayload.builder()
+                .action(AuditAction.CREATE)
+                .status(AuditStatus.FAILURE)
+                .actionId(CREATE_REPLAY_REQUEST)
+                .message(CREATE_REPLAY_REQUEST_MESSAGE)
+                .resources(resources)
+                .user(user)
+                .build();
+    }
+
+    public AuditPayload getCreateReplayRequestSuccess(List<String> resources) {
+        return AuditPayload.builder()
+                .action(AuditAction.CREATE)
+                .status(AuditStatus.SUCCESS)
+                .actionId(CREATE_REPLAY_REQUEST)
+                .message(CREATE_REPLAY_REQUEST_MESSAGE)
+                .resources(resources)
+                .user(user)
+                .build();
+    }
 }
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/logging/StorageAuditLogger.java b/storage-core/src/main/java/org/opengroup/osdu/storage/logging/StorageAuditLogger.java
index d121f278bdb8c3f660a886b30d1223c8c5d538ae..4d12544e96d2b6e657891fe44cdeaf0c484799b7 100644
--- a/storage-core/src/main/java/org/opengroup/osdu/storage/logging/StorageAuditLogger.java
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/logging/StorageAuditLogger.java
@@ -138,6 +138,16 @@ public class StorageAuditLogger {
 		readAuditLogsConsumer.accept(getAuditEvents().getReadMultipleRecordsWithOptionalConversionFail(resource));
 	}
 
+	public void createReplayRequestFail(List<String> resource)
+	{
+		this.writeLog(this.getAuditEvents().getCreateReplayRequestFail(resource));
+	}
+
+	public void createReplayRequestSuccess(List<String> resource)
+	{
+		this.writeLog(this.getAuditEvents().getCreateReplayRequestSuccess(resource));
+	}
+
 	private void writeLog(AuditPayload log) {
 		this.logger.audit(log);
 	}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordId.java b/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordId.java
new file mode 100644
index 0000000000000000000000000000000000000000..a95f8b8ad7cebff779ba069a5d10f5f51bdebb77
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordId.java
@@ -0,0 +1,29 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.model;
+
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+@Builder
+public class RecordId {
+
+    private String id;
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordIdAndKind.java b/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordIdAndKind.java
new file mode 100644
index 0000000000000000000000000000000000000000..84ed9a23abd1f6d75255e14c42f5156f0342461a
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordIdAndKind.java
@@ -0,0 +1,31 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.model;
+
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+@Builder
+public class RecordIdAndKind {
+
+    private String id;
+
+    private String kind;
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordInfoQueryResult.java b/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordInfoQueryResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..5b3282c8d80974458378d7980f74da21f7816f8e
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordInfoQueryResult.java
@@ -0,0 +1,18 @@
+package org.opengroup.osdu.storage.model;
+
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import java.util.List;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@Builder
+public class RecordInfoQueryResult <T> {
+
+    private String cursor;
+
+    private List<T> results;
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordQueryResult.java b/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordQueryResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..d7a4fe3c88e4595684f0b18ebc1a95aa9f941742
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/model/RecordQueryResult.java
@@ -0,0 +1,20 @@
+package org.opengroup.osdu.storage.model;
+
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import org.opengroup.osdu.core.common.model.storage.RecordMetadata;
+
+import java.util.List;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@Builder
+public class RecordQueryResult {
+
+    private String cursor;
+
+    private List<RecordMetadata> results;
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/provider/interfaces/IMessageBus.java b/storage-core/src/main/java/org/opengroup/osdu/storage/provider/interfaces/IMessageBus.java
index 3995362c8cf3beec69c0da05e39a37e6469c2f49..51871802cc19f18cb57e3640504e0e45cdbcc88d 100644
--- a/storage-core/src/main/java/org/opengroup/osdu/storage/provider/interfaces/IMessageBus.java
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/provider/interfaces/IMessageBus.java
@@ -18,12 +18,21 @@ import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.http.DpsHeaders;
 import org.opengroup.osdu.core.common.model.storage.PubSubInfo;
 import org.opengroup.osdu.storage.model.RecordChangedV2;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 
+import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 
+import java.util.Collection;
+
 public interface IMessageBus {
 
     void publishMessage(DpsHeaders headers, PubSubInfo... messages);
 
     void publishMessage(Optional<CollaborationContext> collaborationContext, DpsHeaders headers, RecordChangedV2... messages);
+
+    void publishMessage(DpsHeaders headers,Map<String,String> routingInfo, List<?> messageList);
+
+    void publishMessage(DpsHeaders headers, Map<String,String> routingInfo, PubSubInfo... messages);
 }
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/provider/interfaces/IQueryRepository.java b/storage-core/src/main/java/org/opengroup/osdu/storage/provider/interfaces/IQueryRepository.java
index 7ecf4521efd861ba0917cb5c5b8dd1ad1c764986..7371339a79ff5c5dc88147f34ba450770f9dc322 100644
--- a/storage-core/src/main/java/org/opengroup/osdu/storage/provider/interfaces/IQueryRepository.java
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/provider/interfaces/IQueryRepository.java
@@ -16,7 +16,15 @@ package org.opengroup.osdu.storage.provider.interfaces;
 
 import org.opengroup.osdu.core.common.model.http.CollaborationContext;
 import org.opengroup.osdu.core.common.model.storage.DatastoreQueryResult;
+import org.opengroup.osdu.storage.model.RecordId;
+import org.opengroup.osdu.storage.model.RecordIdAndKind;
+import org.opengroup.osdu.storage.model.RecordInfoQueryResult;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
 
+import java.util.HashMap;
+import java.util.List;
+
+import java.util.Map;
 import java.util.Optional;
 
 public interface IQueryRepository {
@@ -26,4 +34,12 @@ public interface IQueryRepository {
 	DatastoreQueryResult getAllKinds(Integer limit, String cursor);
 
 	DatastoreQueryResult getAllRecordIdsFromKind(String kind, Integer limit, String cursor, Optional<CollaborationContext> collaborationContext);
+
+	RecordInfoQueryResult<RecordIdAndKind> getAllRecordIdAndKind(Integer limit, String cursor);
+
+	RecordInfoQueryResult<RecordId> getAllRecordIdsFromKind(Integer limit, String cursor, String kind);
+
+	HashMap<String, Long> getActiveRecordsCount();
+
+	Map<String, Long> getActiveRecordsCountForKinds(List<String> kinds);
 }
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/provider/interfaces/IReplayRepository.java b/storage-core/src/main/java/org/opengroup/osdu/storage/provider/interfaces/IReplayRepository.java
new file mode 100644
index 0000000000000000000000000000000000000000..a3a05fb149a0e3d787a0d9996a799d3c896bcae2
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/provider/interfaces/IReplayRepository.java
@@ -0,0 +1,30 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.provider.interfaces;
+
+import org.opengroup.osdu.storage.dto.ReplayMetaDataDTO;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+
+import java.util.List;
+
+@ConditionalOnProperty(value = "feature.replay.enabled", havingValue = "true", matchIfMissing = false)
+public interface IReplayRepository {
+
+    List<ReplayMetaDataDTO> getReplayStatusByReplayId(String replayId);
+
+    ReplayMetaDataDTO getReplayStatusByKindAndReplayId(String kind, String replayId);
+
+    ReplayMetaDataDTO save(ReplayMetaDataDTO replayMetaData);
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/request/ReplayFilter.java b/storage-core/src/main/java/org/opengroup/osdu/storage/request/ReplayFilter.java
new file mode 100644
index 0000000000000000000000000000000000000000..07fd6c7a70c3ec980e69e2d2586da80d35398667
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/request/ReplayFilter.java
@@ -0,0 +1,33 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.request;
+
+import jakarta.validation.constraints.Size;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.util.List;
+
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+public class ReplayFilter {
+
+    @Size(min = 1, max = 1, message = "Currently restricted to a single valid kind.")
+    private List<String> kinds;
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/request/ReplayRequest.java b/storage-core/src/main/java/org/opengroup/osdu/storage/request/ReplayRequest.java
new file mode 100644
index 0000000000000000000000000000000000000000..6cadc577406c4a2309f09f6d80b75b932437c7e4
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/request/ReplayRequest.java
@@ -0,0 +1,37 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.request;
+
+import jakarta.validation.Valid;
+import jakarta.validation.constraints.NotEmpty;
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+public class ReplayRequest {
+
+    private String replayId;
+
+    @NotEmpty(message = "Operation field is required. The valid operations are: 'replay', 'reindex'.")
+    private String operation;
+
+    @Valid
+    private ReplayFilter filter;
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/response/ReplayResponse.java b/storage-core/src/main/java/org/opengroup/osdu/storage/response/ReplayResponse.java
new file mode 100644
index 0000000000000000000000000000000000000000..f625bb0376939ecfda113932b3c46cb31b2394a1
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/response/ReplayResponse.java
@@ -0,0 +1,15 @@
+package org.opengroup.osdu.storage.response;
+
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+@Builder
+public class ReplayResponse {
+
+    private String replayId;
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/response/ReplayStatusResponse.java b/storage-core/src/main/java/org/opengroup/osdu/storage/response/ReplayStatusResponse.java
new file mode 100644
index 0000000000000000000000000000000000000000..f44a43ce7bd3f9731b66d76791d3b91f29c3a0d5
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/response/ReplayStatusResponse.java
@@ -0,0 +1,35 @@
+package org.opengroup.osdu.storage.response;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import org.opengroup.osdu.storage.request.ReplayFilter;
+import org.opengroup.osdu.storage.dto.ReplayStatus;
+
+import java.util.Date;
+import java.util.List;
+
+
+@AllArgsConstructor
+@Data
+@NoArgsConstructor
+public class ReplayStatusResponse {
+
+    private String replayId;
+
+    private String operation;
+
+    private Long totalRecords;
+
+    private Date startedAt;
+
+    private String elapsedTime;
+
+    private Long processedRecords;
+
+    private String overallState;
+
+    private ReplayFilter filter;
+
+    private List<ReplayStatus> status;
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/service/replay/IReplayService.java b/storage-core/src/main/java/org/opengroup/osdu/storage/service/replay/IReplayService.java
new file mode 100644
index 0000000000000000000000000000000000000000..867d7b49e9e4019a6adb8d864b1f4470d09ef916
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/service/replay/IReplayService.java
@@ -0,0 +1,31 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.service.replay;
+
+import org.opengroup.osdu.storage.dto.ReplayMessage;
+import org.opengroup.osdu.storage.request.ReplayRequest;
+import org.opengroup.osdu.storage.response.ReplayStatusResponse;
+import org.opengroup.osdu.storage.response.ReplayResponse;
+
+public interface IReplayService {
+
+    ReplayStatusResponse getReplayStatus(String processId);
+
+    void processReplayMessage(ReplayMessage replayKindMessage);
+
+    void processFailure(ReplayMessage replayKindMessage);
+
+    ReplayResponse handleReplayRequest(ReplayRequest replayRequest);
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/service/replay/ReplayService.java b/storage-core/src/main/java/org/opengroup/osdu/storage/service/replay/ReplayService.java
new file mode 100644
index 0000000000000000000000000000000000000000..48f2f51b665d0565250731f2583b41bc9219f2e1
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/service/replay/ReplayService.java
@@ -0,0 +1,387 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.service.replay;
+
+import org.apache.commons.lang3.ObjectUtils;
+import org.apache.http.HttpStatus;
+import org.opengroup.osdu.core.common.model.http.AppException;
+import org.opengroup.osdu.core.common.model.http.DpsHeaders;
+import org.opengroup.osdu.core.common.model.indexer.OperationType;
+import org.opengroup.osdu.core.common.model.storage.PubSubInfo;
+import org.opengroup.osdu.storage.dto.ReplayMessage;
+import org.opengroup.osdu.storage.dto.ReplayMetaDataDTO;
+import org.opengroup.osdu.storage.enums.ReplayOperation;
+import org.opengroup.osdu.storage.logging.StorageAuditLogger;
+import org.opengroup.osdu.storage.model.RecordId;
+import org.opengroup.osdu.storage.model.RecordIdAndKind;
+import org.opengroup.osdu.storage.model.RecordInfoQueryResult;
+import org.opengroup.osdu.storage.provider.interfaces.IMessageBus;
+import org.opengroup.osdu.storage.provider.interfaces.IQueryRepository;
+import org.opengroup.osdu.storage.provider.interfaces.IReplayRepository;
+import org.opengroup.osdu.storage.request.ReplayRequest;
+import org.opengroup.osdu.storage.response.ReplayStatusResponse;
+import org.opengroup.osdu.storage.response.ReplayResponse;
+import org.opengroup.osdu.storage.dto.ReplayData;
+import org.opengroup.osdu.storage.enums.ReplayState;
+import org.opengroup.osdu.storage.enums.ReplayType;
+import org.opengroup.osdu.storage.util.ReplayUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.stereotype.Service;
+import org.springframework.util.StopWatch;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+
+@ConditionalOnProperty(value = "feature.replay.enabled", havingValue = "true", matchIfMissing = false)
+@Service
+@Configuration
+public class ReplayService implements IReplayService {
+    @Autowired
+    private IReplayRepository replayRepository;
+
+    @Autowired
+    private IQueryRepository queryRepository;
+
+    @Autowired
+    private IMessageBus pubSubClient;
+
+    private final static Logger logger = LoggerFactory.getLogger(ReplayService.class);
+
+    @Autowired
+    private DpsHeaders headers;
+
+    @Autowired
+    private StorageAuditLogger auditLogger;
+
+    @Value("#{${replay.operation.routingProperties}}")
+    private Map<String, Map<String, String>> replayOperationRoutingProperties;
+
+    @Value("#{${replay.routingProperties}}")
+    private Map<String, String> replayRoutingProperty;
+
+    public ReplayResponse handleReplayRequest(ReplayRequest replayRequest) {
+
+        Set<String> validReplayOperation = ReplayOperation.getValidReplayOperations();
+        boolean isValidReplayOperation = validReplayOperation.contains(replayRequest.getOperation());
+
+        logger.info("Replay request received: {}", replayRequest);
+
+        if (!isValidReplayOperation)
+            throw new AppException(HttpStatus.SC_BAD_REQUEST,
+                    "Validation Error", "Not a valid operation. The valid operations are: " + validReplayOperation);
+
+        if (!(ObjectUtils.isEmpty(replayRequest.getFilter()) || ObjectUtils.isEmpty(replayRequest.getFilter().getKinds())))
+            return this.replay(replayRequest, ReplayType.REPLAY_KIND);
+
+        return this.replay(replayRequest, ReplayType.REPLAY_ALL);
+    }
+
+    private ReplayResponse replay(ReplayRequest replayRequest, ReplayType replayOperation) {
+
+        List<ReplayMessage> replayMessageList = this.generateReplayMessageList(replayRequest, replayOperation);
+        ReplayMetaDataDTO replayMetaData = ReplayMetaDataDTO.builder()
+                                                            .id(UUID.randomUUID().toString())
+                                                            .replayId(replayRequest.getReplayId())
+                                                            .totalRecords(getTotalRecordCount(replayMessageList))
+                                                            .startedAt(ReplayUtils.formatMillisToDate(System.currentTimeMillis()))
+                                                            .operation(replayRequest.getOperation())
+                                                            .filter(replayRequest.getFilter())
+                                                            .build();
+
+        return this.startReplay(replayMessageList, replayMetaData);
+    }
+
+    private Long getTotalRecordCount(List<ReplayMessage> replayMessageList) {
+
+        return replayMessageList.stream().mapToLong(item -> item.getBody().getTotalCount()).sum();
+    }
+
+    private List<ReplayMessage> generateReplayMessageList(ReplayRequest replayRequest, ReplayType replayType) throws AppException {
+
+        Map<String, Long> countByKind = (replayType == ReplayType.REPLAY_ALL) ?
+                queryRepository.getActiveRecordsCount() : queryRepository.getActiveRecordsCountForKinds(replayRequest.getFilter().getKinds());
+
+        if (countByKind == null || countByKind.isEmpty())
+            throw new AppException(HttpStatus.SC_BAD_REQUEST,
+                    "Kind is invalid.", "The requested kind does not exist."
+            );
+
+        List<ReplayMessage> replayMessages = new ArrayList<>();
+        int kindCounter = 0;
+
+        for (Map.Entry<String, Long> item : countByKind.entrySet()) {
+            long startedAtTimestamp = System.currentTimeMillis();
+
+            ReplayData body = ReplayData.builder()
+                                        .id(UUID.randomUUID().toString())
+                                        .replayType(replayType.name())
+                                        .replayId(replayRequest.getReplayId())
+                                        .startAtTimestamp(startedAtTimestamp)
+                                        .operation(replayRequest.getOperation())
+                                        .completionCount(0L)
+                                        .totalCount(item.getValue())
+                                        .kind(item.getKey())
+                                        .build();
+
+            String messageCorrelationId = ReplayUtils.getNextCorrelationId(headers.getCorrelationId(), Optional.of(kindCounter));
+            ReplayMessage message = ReplayMessage.builder()
+                                                 .body(body)
+                                                 .headers(ReplayUtils.createHeaders(
+                                                         headers.getPartitionId(),
+                                                         messageCorrelationId))
+                                                 .build();
+
+            logger.info("The replay message {} with new correlation ID {}", message, messageCorrelationId);
+            replayMessages.add(message);
+            kindCounter++;
+        }
+
+        return replayMessages;
+    }
+
+    private ReplayResponse startReplay(List<ReplayMessage> replayMessages, ReplayMetaDataDTO replayMetaData) {
+
+        try {
+            replayRepository.save(replayMetaData);
+            pubSubClient.publishMessage(headers, replayRoutingProperty, replayMessages);
+        } catch (Exception e) {
+
+            logger.error("Exception occurred during start replay operation for replayId {} is ", replayMetaData.getReplayId(), e);
+            auditLogger.createReplayRequestFail(Collections.singletonList(replayMetaData.toString()));
+            throw new AppException(
+                    HttpStatus.SC_INTERNAL_SERVER_ERROR,
+                    "The exception occurred during the start replay operation.",
+                    "Request could not be processed due to an internal server issue."
+            );
+        }
+        auditLogger.createReplayRequestSuccess(Collections.singletonList(replayMetaData.toString()));
+        return ReplayResponse.builder().replayId(replayMetaData.getReplayId()).build();
+    }
+
+    public ReplayStatusResponse getReplayStatus(String replayId) {
+        List<ReplayMetaDataDTO> replayMetaDataDTOList = replayRepository.getReplayStatusByReplayId(replayId);
+
+        if (ObjectUtils.isEmpty(replayMetaDataDTOList))
+            throw new AppException(
+                    HttpStatus.SC_NOT_FOUND,
+                    "Replay ID does not exist.",
+                    "The replay ID " + replayId + " is invalid."
+            );
+
+        ReplayStatusResponse response = new ReplayStatusResponse();
+        response.setReplayId(replayId);
+        response.setStatus(new ArrayList<>());
+        long totalProcessedRecords = 0;
+
+        boolean allQueued = true;
+        boolean hasFailed = false;
+        boolean hasInProgress = false;
+
+        for (ReplayMetaDataDTO replayMetaDataDTO : replayMetaDataDTOList) {
+            if (replayMetaDataDTO.getKind() == null) {
+                response.setOperation(replayMetaDataDTO.getOperation());
+                response.setFilter(replayMetaDataDTO.getFilter());
+                response.setTotalRecords(replayMetaDataDTO.getTotalRecords());
+                response.setStartedAt(replayMetaDataDTO.getStartedAt());
+            }
+            else {
+                Long processedRecords = replayMetaDataDTO.getProcessedRecords();
+                totalProcessedRecords += processedRecords != null ? processedRecords : 0;
+                response.setOverallState(replayMetaDataDTO.getState());
+                response.getStatus().add(ReplayUtils.convertToReplayStatusDTO(replayMetaDataDTO));
+
+                String state = replayMetaDataDTO.getState();
+                if (state.equals(ReplayState.FAILED.name())) {
+                    hasFailed = true;
+                    allQueued = false;
+                }
+                else if (state.equals(ReplayState.IN_PROGRESS.name())) {
+                    hasInProgress = true;
+                    allQueued = false;
+                }
+                else if (!state.equals(ReplayState.QUEUED.name())) {
+                    allQueued = false;
+                }
+            }
+        }
+
+        // Determine overall status based on the flags
+        if (allQueued) {
+            response.setOverallState(ReplayState.QUEUED.name());
+        }
+        else if (hasFailed) {
+            response.setOverallState(ReplayState.FAILED.name());
+        }
+        else if (hasInProgress) {
+            response.setOverallState(ReplayState.IN_PROGRESS.name());
+        }
+        else {
+            response.setOverallState(ReplayState.COMPLETED.name());
+        }
+        response.setProcessedRecords(totalProcessedRecords);
+
+        logger.info("GET Replay status operation successful. Replay status: {}", response);
+        return response;
+    }
+
+    @Override
+    public void processFailure(ReplayMessage replayMessage) {
+
+        ReplayMetaDataDTO replayMetadata = replayRepository.getReplayStatusByKindAndReplayId(
+                replayMessage.getBody().getKind(),
+                replayMessage.getBody().getReplayId()
+                                                                                            );
+        replayMetadata.setState(ReplayState.FAILED.name());
+        replayRepository.save(replayMetadata);
+        auditLogger.createReplayRequestFail(Collections.singletonList(replayMetadata.toString()));
+        logger.error("Replay Operation with given metadata failed : {}", replayMetadata);
+    }
+
+    public void processReplayMessage(ReplayMessage replayMessage) {
+
+        String kind = replayMessage.getBody().getKind();
+        String replayId = replayMessage.getBody().getReplayId();
+        StopWatch stopWatch = new StopWatch();
+
+        stopWatch.start("Fetch Record");
+        RecordInfoQueryResult<RecordIdAndKind> recordInfoQueryResult = getRecordIdsAndKind(replayMessage);
+        stopWatch.stop();
+
+        logger.info("TaskName : {}, RecordIdsCount : {}, OperationTime : {} ms", stopWatch.getLastTaskName(),
+                recordInfoQueryResult.getResults() == null ? 0 : recordInfoQueryResult.getResults().size(), stopWatch.getLastTaskTimeMillis());
+
+        stopWatch.start("Published RecordChangedMessages");
+        publishRecordChangedMessages(recordInfoQueryResult.getResults(), replayOperationRoutingProperties.get(replayMessage.getBody().getOperation()));
+        stopWatch.stop();
+
+        logger.info("TaskName : {}, RecordIdsCount : {}, OperationTime : {} ms", stopWatch.getLastTaskName(),
+                recordInfoQueryResult.getResults().size(), stopWatch.getLastTaskTimeMillis());
+
+        ReplayMetaDataDTO progress = saveProgress(replayMessage, recordInfoQueryResult.getResults().size(),
+                recordInfoQueryResult.getCursor() == null ? ReplayState.COMPLETED : ReplayState.IN_PROGRESS
+                                                 );
+
+        logger.info("Replay operation progress tracked for ReplayId= {}, Kind= {}, Status= {}, ElapsedTime= {}, TotalRecord= {}",
+                replayId, kind, progress.getState(), progress.getElapsedTime(), progress.getTotalRecords());
+
+        if (recordInfoQueryResult.getCursor() == null)
+            return;
+
+        stopWatch.start("Publishing the Replay Message");
+
+        String messageCorrelationId = ReplayUtils.getNextCorrelationId(headers.getCorrelationId(), Optional.empty());
+        Map<String, String> newHeaders = ReplayUtils.createHeaders(headers.getPartitionId(), messageCorrelationId);
+
+        ReplayData newData = ReplayData.builder().operation(replayMessage.getBody().getOperation())
+                                       .id(replayMessage.getBody().getId())
+                                       .kind(kind)
+                                       .replayId(replayId)
+                                       .replayType(replayMessage.getBody().getReplayType())
+                                       .startAtTimestamp(replayMessage.getBody().getStartAtTimestamp())
+                                       .completionCount(progress.getProcessedRecords())
+                                       .totalCount(replayMessage.getBody().getTotalCount())
+                                       .cursor(recordInfoQueryResult.getCursor())
+                                       .build();
+
+        ReplayMessage newMessage = ReplayMessage.builder().headers(newHeaders).body(newData).build();
+        logger.info("The replay message {} with new correlation ID {}", newMessage, messageCorrelationId);
+        List<ReplayMessage> newMessages = new ArrayList<>();
+        newMessages.add(newMessage);
+        this.pubSubClient.publishMessage(headers, replayRoutingProperty, newMessages);
+        stopWatch.stop();
+
+        logger.info("Processed ReplayMessage in {} ms", stopWatch.getTotalTimeMillis());
+    }
+
+    private RecordInfoQueryResult<RecordIdAndKind> getRecordIdsAndKind(ReplayMessage replayMessage) {
+
+        RecordInfoQueryResult<RecordIdAndKind> recordInfoQueryResult = new RecordInfoQueryResult<>();
+        Map<String, String> routingInfo = replayOperationRoutingProperties.get(replayMessage.getBody().getOperation());
+        int BATCH_SIZE = Integer.parseInt(routingInfo.get("queryBatchSize"));
+
+        if (replayMessage.getBody().getReplayType().equals(ReplayType.REPLAY_KIND.name())) {
+
+            List<RecordIdAndKind> result = new ArrayList<>();
+            RecordInfoQueryResult<RecordId> queryResult = queryRepository.getAllRecordIdsFromKind(
+                    BATCH_SIZE,
+                    replayMessage.getBody().getCursor(),
+                    replayMessage.getBody().getKind()
+                                                                                                 );
+
+            for (RecordId recordId : queryResult.getResults()) {
+                result.add(RecordIdAndKind.builder().id(recordId.getId()).kind(replayMessage.getBody().getKind()).build());
+            }
+
+            recordInfoQueryResult.setResults(result);
+            recordInfoQueryResult.setCursor(queryResult.getCursor());
+
+        }
+        else if (replayMessage.getBody().getReplayType().equals(ReplayType.REPLAY_ALL.name())) {
+
+            recordInfoQueryResult = queryRepository.getAllRecordIdAndKind(
+                    BATCH_SIZE,
+                    replayMessage.getBody().getCursor());
+        }
+        return recordInfoQueryResult;
+    }
+
+    private ReplayMetaDataDTO saveProgress(ReplayMessage replayMessage, int count, ReplayState replayState) {
+
+        long totalElapsedInMillis = System.currentTimeMillis() - replayMessage.getBody().getStartAtTimestamp();
+
+        String kind = replayMessage.getBody().getKind();
+        String replayId = replayMessage.getBody().getReplayId();
+
+        ReplayMetaDataDTO progress = ReplayMetaDataDTO.builder()
+                                                      .id(replayMessage.getBody().getId())
+                                                      .kind(kind)
+                                                      .replayId(replayId)
+                                                      .processedRecords(replayMessage.getBody().getCompletionCount() + count)
+                                                      .totalRecords(replayMessage.getBody().getTotalCount())
+                                                      .state(replayState.name())
+                                                      .startedAt(new Date(replayMessage.getBody().getStartAtTimestamp()))
+                                                      .elapsedTime(ReplayUtils.formatMillisToHoursMinutesSeconds(totalElapsedInMillis))
+                                                      .build();
+
+        logger.info("Replay Progress : {}", progress.toString());
+        return replayRepository.save(progress);
+    }
+
+    private void publishRecordChangedMessages(List<RecordIdAndKind> recordQueryResult, Map<String, String> routingProperties) {
+
+        PubSubInfo[] pubSubInfo = new PubSubInfo[recordQueryResult.size()];
+        int index = 0;
+        for (RecordIdAndKind recordIdAndKind : recordQueryResult) {
+            if (recordIdAndKind != null && recordIdAndKind.getId() != null)
+                pubSubInfo[index++] = PubSubInfo.builder().
+                                                kind(recordIdAndKind.getKind())
+                                                .id(recordIdAndKind.getId())
+                                                .op(OperationType.create)
+                                                .build();
+        }
+        pubSubClient.publishMessage(headers, routingProperties, pubSubInfo);
+    }
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/util/GlobalExceptionMapper.java b/storage-core/src/main/java/org/opengroup/osdu/storage/util/GlobalExceptionMapper.java
index 9ba3ae67fe37b16d7231fa03c0a92d53531553e4..9fcc955020d5353ccfcbbbed23db7cbf4b2166de 100644
--- a/storage-core/src/main/java/org/opengroup/osdu/storage/util/GlobalExceptionMapper.java
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/util/GlobalExceptionMapper.java
@@ -47,7 +47,9 @@ import org.springframework.http.ResponseEntity;
 import org.springframework.http.converter.HttpMessageNotReadableException;
 import org.springframework.lang.NonNull;
 import org.springframework.security.access.AccessDeniedException;
+import org.springframework.validation.BindingResult;
 import org.springframework.web.HttpRequestMethodNotSupportedException;
+import org.springframework.web.bind.MethodArgumentNotValidException;
 import org.springframework.web.bind.annotation.ControllerAdvice;
 import org.springframework.web.bind.annotation.ExceptionHandler;
 import org.springframework.web.context.request.WebRequest;
@@ -196,4 +198,13 @@ public class GlobalExceptionMapper extends ResponseEntityExceptionHandler {
         node.put("message", message);
         return node;
     }
+
+
+    @Override
+    protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {
+        BindingResult bindingResult = ex.getBindingResult();
+        String errorMessage = bindingResult.getAllErrors().get(0).getDefaultMessage();
+        return this.getErrorResponse(
+                new AppException(HttpStatus.BAD_REQUEST.value(), "Validation error.",errorMessage));
+    }
 }
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/util/ReplayUtils.java b/storage-core/src/main/java/org/opengroup/osdu/storage/util/ReplayUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c9b2c3d597c36a3c46d75f5cdb46e864a222151
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/util/ReplayUtils.java
@@ -0,0 +1,74 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.util;
+
+import org.opengroup.osdu.core.common.model.http.DpsHeaders;
+import org.opengroup.osdu.storage.dto.ReplayMetaDataDTO;
+import org.opengroup.osdu.storage.dto.ReplayStatus;
+
+import java.time.Instant;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+import java.util.concurrent.TimeUnit;
+
+public final class ReplayUtils {
+
+    public static Map<String, String> createHeaders(String dataPartitionId, String correlationId) {
+        Map<String, String> headers = new HashMap<>();
+        headers.put(DpsHeaders.DATA_PARTITION_ID, dataPartitionId);
+        headers.put(DpsHeaders.CORRELATION_ID, correlationId);
+        return headers;
+    }
+
+    public static String getNextCorrelationId(String correlationId, Optional<Integer> kindCounter) {
+
+
+        if (kindCounter.isPresent()) {
+            correlationId = correlationId.substring(0, Math.min(correlationId.length(), 64));
+            return correlationId + "_kind_" + kindCounter.get() + "_SEQ_0";
+        }
+
+        String[] split = correlationId.split("_SEQ_");
+        int seqNo = Integer.parseInt(split[1]) + 1;
+        return split[0] + "_SEQ_" + seqNo;
+    }
+
+    public static ReplayStatus convertToReplayStatusDTO(ReplayMetaDataDTO replayMetaDataDTO) {
+
+        return ReplayStatus.builder().kind(replayMetaDataDTO.getKind()).
+                           state(replayMetaDataDTO.getState()).
+                           startedAt(replayMetaDataDTO.getStartedAt()).
+                           totalRecords(replayMetaDataDTO.getTotalRecords()).
+                           processedRecords(replayMetaDataDTO.getProcessedRecords()).
+                           elapsedTime(replayMetaDataDTO.getElapsedTime()).build();
+    }
+
+    public static Date formatMillisToDate(long timeMillis) {
+
+        Instant instant = Instant.ofEpochMilli(timeMillis);
+        return Date.from(instant);
+    }
+
+    public static String formatMillisToHoursMinutesSeconds(long elapsedMillis) {
+
+        long seconds = TimeUnit.MILLISECONDS.toSeconds(elapsedMillis);
+        long minutes = TimeUnit.MILLISECONDS.toMinutes(elapsedMillis);
+        long hours = TimeUnit.MILLISECONDS.toHours(elapsedMillis);
+
+        return String.format("%dh %dm %ds", hours, minutes % 60, seconds % 60);
+    }
+}
diff --git a/storage-core/src/main/java/org/opengroup/osdu/storage/util/Role.java b/storage-core/src/main/java/org/opengroup/osdu/storage/util/Role.java
new file mode 100644
index 0000000000000000000000000000000000000000..3dfea6e59ea44c068a8aedb0902af9e949930778
--- /dev/null
+++ b/storage-core/src/main/java/org/opengroup/osdu/storage/util/Role.java
@@ -0,0 +1,5 @@
+package org.opengroup.osdu.storage.util;
+
+public final class Role {
+    public static final String USER_OPS = "users.datalake.ops";
+}
diff --git a/storage-core/src/main/resources/swagger.properties b/storage-core/src/main/resources/swagger.properties
index c4c05167ef61e51d0ea0890576ea20cba9b5998a..d2eaee1da75d9632b7200704a3c00e86c4c8671b 100644
--- a/storage-core/src/main/resources/swagger.properties
+++ b/storage-core/src/main/resources/swagger.properties
@@ -84,6 +84,12 @@ infoApi.info.description=For deployment available public `/info` endpoint, which
 healthCheckApi.livenessCheck.summary=Liveness Check endpoint
 healthCheckApi.livenessCheck.description=For deployment available public `/liveness_check` endpoint verifies the operational status of the Storage Service.
 
+#Replay API
+replayApi.triggerReplay=Replay Based on Filter.
+replayApi.triggerReplay.description=The API trigger the replay based on operation and filter.\nRequired roles: users.datalake.ops ``.
+replayApi.getReplayStatus=Get Replay Status.
+replayApi.getReplayStatus.description=The API fetches replay status based on replay id.\nRequired roles: users.datalake.ops ``.
+
 #Record references copy API related properties
 recordReferencesApi.copyRecordReferences.summary=Copy Record references form one namespace to another
 recordReferencesApi.copyRecordReferences.description=This API attempts to copy all the Record references it is provided from the given source namespace to the target namespace. All references will be copied or all will fail as a transaction. If the target namespace does not et exist it will be created. It requires 'services.storage.admin' permission to call
diff --git a/storage-core/src/test/java/org/opengroup/osdu/storage/api/ReplayApiTest.java b/storage-core/src/test/java/org/opengroup/osdu/storage/api/ReplayApiTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..0fdb48a9552523dab22c691199f210a4ea3e4d07
--- /dev/null
+++ b/storage-core/src/test/java/org/opengroup/osdu/storage/api/ReplayApiTest.java
@@ -0,0 +1,69 @@
+package org.opengroup.osdu.storage.api;
+
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.opengroup.osdu.core.common.http.CollaborationContextFactory;
+import org.opengroup.osdu.core.common.model.http.AppException;
+import org.opengroup.osdu.core.common.model.http.CollaborationContext;
+import org.opengroup.osdu.core.common.model.http.DpsHeaders;
+import org.opengroup.osdu.core.common.model.tenant.TenantInfo;
+import org.opengroup.osdu.storage.request.ReplayRequest;
+import org.opengroup.osdu.storage.response.ReplayResponse;
+import org.springframework.http.ResponseEntity;
+
+import java.util.Optional;
+import java.util.UUID;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+@ExtendWith(MockitoExtension.class)
+public class ReplayApiTest {
+
+    private final String USER = "user";
+    private final String TENANT = "tenant1";
+    private final String COLLABORATION_DIRECTIVES = "id=9e1c4e74-3b9b-4b17-a0d5-67766558ec65,application=TestApp";
+    private final Optional<CollaborationContext> COLLABORATION_CONTEXT = Optional.ofNullable(CollaborationContext.builder().id(UUID.fromString("9e1c4e74-3b9b-4b17-a0d5-67766558ec65")).application("TestApp").build());
+
+    @Mock
+    private CollaborationContextFactory collaborationContextFactory;
+
+    @InjectMocks
+    private ReplayApi sut;
+
+    @Mock
+    private DpsHeaders httpHeaders;
+
+    @BeforeEach
+    public void setup() {
+
+        initMocks(this);
+        lenient().when(this.httpHeaders.getUserEmail()).thenReturn(this.USER);
+        lenient().when(this.collaborationContextFactory.create(eq(COLLABORATION_DIRECTIVES))).thenReturn(Optional.empty());
+        TenantInfo tenant = new TenantInfo();
+        tenant.setName(this.TENANT);
+    }
+
+    @Test
+    public void should_returnsHttp501_when_creatingReplayRequestWithCollaborationHeader() {
+
+        ReplayRequest replayRequest = new ReplayRequest();
+        replayRequest.setOperation("replay");
+        lenient().when(this.collaborationContextFactory.create(eq(COLLABORATION_DIRECTIVES))).thenReturn(COLLABORATION_CONTEXT);
+        try {
+            ResponseEntity<ReplayResponse> response = this.sut.triggerReplay(COLLABORATION_DIRECTIVES, replayRequest);
+        } catch (AppException e) {
+            assertEquals(501, e.getError().getCode());
+            assertEquals("Collaboration feature not implemented for Replay API.", e.getError().getReason());
+            assertEquals("Collaboration feature is not yet supported for the Replay API.", e.getError().getMessage());
+        }
+    }
+
+}
diff --git a/storage-core/src/test/java/org/opengroup/osdu/storage/service/ReplayServiceTest.java b/storage-core/src/test/java/org/opengroup/osdu/storage/service/ReplayServiceTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..9d964383d01d057e4dd436d8de46311a3193ef4d
--- /dev/null
+++ b/storage-core/src/test/java/org/opengroup/osdu/storage/service/ReplayServiceTest.java
@@ -0,0 +1,350 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.service;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.opengroup.osdu.core.common.model.http.AppException;
+import org.opengroup.osdu.core.common.model.http.DpsHeaders;
+import org.opengroup.osdu.storage.dto.ReplayData;
+import org.opengroup.osdu.storage.dto.ReplayMessage;
+import org.opengroup.osdu.storage.dto.ReplayMetaDataDTO;
+import org.opengroup.osdu.storage.enums.ReplayState;
+import org.opengroup.osdu.storage.enums.ReplayType;
+import org.opengroup.osdu.storage.logging.StorageAuditLogger;
+import org.opengroup.osdu.storage.model.RecordId;
+import org.opengroup.osdu.storage.model.RecordIdAndKind;
+import org.opengroup.osdu.storage.model.RecordInfoQueryResult;
+import org.opengroup.osdu.storage.provider.interfaces.IMessageBus;
+import org.opengroup.osdu.storage.provider.interfaces.IQueryRepository;
+import org.opengroup.osdu.storage.provider.interfaces.IReplayRepository;
+import org.opengroup.osdu.storage.request.ReplayFilter;
+import org.opengroup.osdu.storage.request.ReplayRequest;
+
+import org.opengroup.osdu.storage.response.ReplayResponse;
+import org.opengroup.osdu.storage.response.ReplayStatusResponse;
+import org.opengroup.osdu.storage.service.replay.ReplayService;
+import org.opengroup.osdu.storage.util.ReplayUtils;
+import org.springframework.test.util.ReflectionTestUtils;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.UUID;
+
+import static org.junit.jupiter.api.Assertions.*;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyList;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+@ExtendWith(MockitoExtension.class)
+public class ReplayServiceTest {
+
+    private static final String KIND = "opendes:ds:inttest:1.0.4178321727827";
+    @Mock
+    private IReplayRepository replayRepository;
+
+    @Mock
+    private IQueryRepository queryRepository;
+
+    @Mock
+    private DpsHeaders headers;
+
+    @Mock
+    private StorageAuditLogger auditLogger;
+
+    @Mock
+    private IMessageBus pubSubClient;
+
+    @InjectMocks
+    ReplayService replayService;
+
+
+    @BeforeEach
+    public void setup() {
+
+        Map<String, Map<String, String>> resultMap = new HashMap<>();
+        Map<String, String> reindexMap = new HashMap<>();
+        reindexMap.put("topic", "reindextopic");
+        reindexMap.put("queryBatchSize", "5000");
+        reindexMap.put("publisherBatchSize", "50");
+
+
+        Map<String, String> replayMap = new HashMap<>();
+        replayMap.put("topic", "recordstopic");
+        replayMap.put("queryBatchSize", "5000");
+        replayMap.put("publisherBatchSize", "50");
+
+
+        resultMap.put("reindex", reindexMap);
+        resultMap.put("replay", replayMap);
+
+        ReflectionTestUtils.setField(replayService, "replayOperationRoutingProperties", resultMap);
+
+        lenient().when(headers.getCorrelationId()).thenReturn(UUID.randomUUID().toString());
+        lenient().when(headers.getPartitionId()).thenReturn("dp1");
+        lenient().when(headers.getCorrelationId()).thenReturn("dummy@osdu.com");
+
+    }
+
+    @Test
+    public void testHandleReplayRequest_given_replayAll() {
+
+        ReplayRequest replayRequest = new ReplayRequest();
+        String replayId = UUID.randomUUID().toString();
+        replayRequest.setOperation("reindex");
+        replayRequest.setReplayId(replayId);
+        HashMap<String, Long> recordCountByKind = new HashMap<>();
+        Map<String, String> replayConfig = new HashMap<>();
+        recordCountByKind.put("*", 10L);
+
+
+        ReplayMetaDataDTO replayMetaData = ReplayMetaDataDTO.builder().replayId(UUID.randomUUID().toString()).totalRecords(10L)
+                                                            .startedAt(new Date(System.currentTimeMillis()))
+                                                            .operation(replayRequest.getOperation())
+                                                            .filter(replayRequest.getFilter())
+                                                            .build();
+
+        when(queryRepository.getActiveRecordsCount()).thenReturn(recordCountByKind);
+        when(replayRepository.save(any())).thenReturn(replayMetaData);
+        ReplayResponse response = this.replayService.handleReplayRequest(replayRequest);
+        verify(pubSubClient,times(1)).publishMessage(any(), any(),anyList());
+        assertEquals(replayId,response.getReplayId());
+    }
+
+    @Test
+    public void testHandleReplayRequest_given_replayByKind() {
+
+        String replayId = UUID.randomUUID().toString();
+        ReplayRequest replayRequest = new ReplayRequest();
+        replayRequest.setOperation("reindex");
+        ReplayFilter replayFilter = new ReplayFilter();
+        replayFilter.setKinds(Arrays.asList(KIND));
+        replayRequest.setFilter(replayFilter);
+        replayRequest.setReplayId(replayId);
+
+        HashMap<String, Long> recordCountByKind = new HashMap<>();
+        Map<String, String> replayConfig = new HashMap<>();
+        recordCountByKind.put(KIND, 10L);
+
+        ReplayMetaDataDTO replayMetaData = ReplayMetaDataDTO.builder().replayId(replayRequest.getReplayId()).totalRecords(10L)
+                                                            .startedAt(new Date(System.currentTimeMillis()))
+                                                            .operation(replayRequest.getOperation())
+                                                            .filter(replayRequest.getFilter())
+                                                            .build();
+
+        when(queryRepository.getActiveRecordsCountForKinds(replayRequest.getFilter().getKinds())).thenReturn(recordCountByKind);
+        when(replayRepository.save(any())).thenReturn(replayMetaData);
+        ReplayResponse response = this.replayService.handleReplayRequest(replayRequest);
+        verify(pubSubClient,times(1)).publishMessage(any(), any(),anyList());
+        assertEquals(replayId,response.getReplayId());
+    }
+
+
+    @Test
+    public void testHandleReplayRequest_givenInvalidKind() {
+
+        ReplayRequest replayRequest = new ReplayRequest();
+        ReplayResponse expectedResponse = new ReplayResponse();
+        replayRequest.setOperation("invalidOperation");
+        try {
+            ReplayResponse response = replayService.handleReplayRequest(replayRequest);
+        }
+        catch (AppException e) {
+            assertEquals("Not a valid operation. The valid operations are: [reindex, replay]", e.getMessage());
+        }
+    }
+
+    @Test
+    public void testHandleReplayRequest_given_invalidKind() {
+
+
+        ReplayRequest replayRequest = new ReplayRequest();
+        ReplayResponse expectedResponse = new ReplayResponse();
+        replayRequest.setOperation("reindex");
+        ReplayFilter replayFilter = new ReplayFilter();
+        replayFilter.setKinds(Arrays.asList(KIND));
+        replayRequest.setFilter(replayFilter);
+        HashMap<String, Long> recordCountByKind = new HashMap<>();
+        Map<String, String> replayConfig = new HashMap<>();
+
+
+
+        List<Object> replayMessages = new ArrayList<>();
+
+
+        ReplayMetaDataDTO replayMetaData = ReplayMetaDataDTO.builder().replayId(replayRequest.getReplayId()).totalRecords(10L)
+                                                            .startedAt(new Date(System.currentTimeMillis()))
+                                                            .operation(replayRequest.getOperation())
+                                                            .filter(replayRequest.getFilter())
+                                                            .build();
+
+        when(queryRepository.getActiveRecordsCountForKinds(replayRequest.getFilter().getKinds())).thenReturn(recordCountByKind);
+
+        try {
+            ReplayResponse response = replayService.handleReplayRequest(replayRequest);
+        }
+        catch (AppException e) {
+            assertEquals("The requested kind does not exist.", e.getMessage());
+        }
+    }
+
+    @Test
+    public void test_processMessage_given_replayAll() {
+
+        String id = "opendes:inttest:1.0.4178321727827";
+        String replayId = UUID.randomUUID().toString();
+        ReplayData body = ReplayData.builder()
+                                    .id(UUID.randomUUID().toString())
+                                    .replayType(ReplayType.REPLAY_ALL.name())
+                                    .replayId(replayId)
+                                    .startAtTimestamp(System.currentTimeMillis())
+                                    .operation("reindex")
+                                    .completionCount(0L)
+                                    .totalCount(10L)
+                                    .kind("*")
+                                    .build();
+
+        lenient().when(headers.getCorrelationId()).thenReturn(UUID.randomUUID().toString()+ "_kind_0_SEQ_0");
+        ReplayMessage message = ReplayMessage.builder()
+                                             .body(body)
+                                             .headers(ReplayUtils.createHeaders(
+                                                     headers.getPartitionId(),
+                                                     ReplayUtils.getNextCorrelationId(headers.getCorrelationId(), Optional.empty()))).build();
+
+        ReplayMetaDataDTO replayMetaData = ReplayMetaDataDTO.builder().
+                                                            replayId(replayId)
+                                                            .totalRecords(10L)
+                                                            .processedRecords(5000L)
+                                                            .startedAt(new Date(System.currentTimeMillis()))
+                                                            .operation(message.getBody().getOperation())
+                                                            .filter(null)
+                                                            .build();
+
+        RecordIdAndKind recordIdAndKind = new RecordIdAndKind();
+        recordIdAndKind.setKind(KIND);
+        recordIdAndKind.setId(id);
+        RecordInfoQueryResult<RecordIdAndKind> recordInfoQueryResult = new RecordInfoQueryResult<>();
+        recordInfoQueryResult.setResults(Arrays.asList(recordIdAndKind));
+        recordInfoQueryResult.setCursor("dummyCursor");
+
+        when(queryRepository.getAllRecordIdAndKind(any(),any())).thenReturn(recordInfoQueryResult);
+        when(replayRepository.save(any())).thenReturn(replayMetaData);
+        replayService.processReplayMessage(message);
+        verify(replayRepository,times(1)).save(any());
+        verify(queryRepository,times(1)).getAllRecordIdAndKind(5000,null);
+    }
+
+    @Test
+    public void test_processMessage_given_replayByKind() {
+
+        String id = "opendes:inttest:1.0.4178321727827";
+        String replayId = UUID.randomUUID().toString();
+        Map<String, String> replayConfig = new HashMap<>();
+        ReplayData body = ReplayData.builder()
+                                    .id(UUID.randomUUID().toString())
+                                    .replayType(ReplayType.REPLAY_KIND.name())
+                                    .replayId(replayId)
+                                    .startAtTimestamp(System.currentTimeMillis())
+                                    .operation("reindex")
+                                    .completionCount(0L)
+                                    .totalCount(10L)
+                                    .kind(KIND)
+                                    .build();
+
+        lenient().when(headers.getCorrelationId()).thenReturn(UUID.randomUUID().toString()+ "_kind_0_SEQ_0");
+        ReplayMessage message = ReplayMessage.builder()
+                                             .body(body)
+                                             .headers(ReplayUtils.createHeaders(
+                                                     headers.getPartitionId(),
+                                                     ReplayUtils.getNextCorrelationId(headers.getCorrelationId(),Optional.empty()))).build();
+
+        ReplayMetaDataDTO replayMetaData = ReplayMetaDataDTO.builder().
+                                                            replayId(replayId)
+                                                            .totalRecords(10L)
+                                                            .processedRecords(5000L)
+                                                            .startedAt(new Date(System.currentTimeMillis()))
+                                                            .operation(message.getBody().getOperation())
+                                                            .filter(null)
+                                                            .build();
+
+        RecordId recordId = new RecordId();
+        recordId.setId(id);
+        RecordInfoQueryResult<RecordId> recordInfoQueryResult = new RecordInfoQueryResult<>();
+        recordInfoQueryResult.setCursor("dummyCursor");
+        recordInfoQueryResult.setResults(Arrays.asList(recordId));
+
+        when(queryRepository.getAllRecordIdsFromKind(5000, message.getBody().getCursor(), message.getBody().getKind())).thenReturn(recordInfoQueryResult);
+
+        when(replayRepository.save(any())).thenReturn(replayMetaData);
+
+
+        this.replayService.processReplayMessage(message);
+        verify(replayRepository,times(1)).save(any());
+        verify(queryRepository,times(1)).getAllRecordIdsFromKind(5000,message.getBody().getCursor(), message.getBody().getKind());
+    }
+
+    @Test
+    public void test_replayGetStatus_given_invalidReplayId() {
+
+        String replayId = UUID.randomUUID().toString();
+        when(replayRepository.getReplayStatusByReplayId(replayId)).thenReturn(new ArrayList<ReplayMetaDataDTO>());
+        try {
+            ReplayStatusResponse response = replayService.getReplayStatus(replayId);
+        } catch (Exception e) {
+            assertEquals("The replay ID "+ replayId + " is invalid.",e.getMessage());;
+        }
+    }
+
+    @Test
+    public void test_replayGetStatus_given_validReplayId() {
+
+        List<String> kinds = Arrays.asList(KIND);
+        String replayId = UUID.randomUUID().toString();
+        ReplayMetaDataDTO metaDataDTO = new ReplayMetaDataDTO();
+        metaDataDTO.setTotalRecords(10L);
+        ReplayFilter replayFilter = new ReplayFilter();
+        replayFilter.setKinds(kinds);
+        metaDataDTO.setReplayId(replayId);
+        metaDataDTO.setFilter(replayFilter);
+        metaDataDTO.setOperation("reindex");
+
+        ReplayMetaDataDTO statusDataDTO = new ReplayMetaDataDTO();
+        statusDataDTO.setTotalRecords(10L);
+        statusDataDTO.setKind(KIND);
+        statusDataDTO.setProcessedRecords(10L);
+        statusDataDTO.setStartedAt(new Date(System.currentTimeMillis()));
+        statusDataDTO.setElapsedTime(ReplayUtils.formatMillisToHoursMinutesSeconds(System.currentTimeMillis()));
+        statusDataDTO.setState(ReplayState.COMPLETED.name());
+
+        List<ReplayMetaDataDTO> replayMetaDataDTOList = Arrays.asList(metaDataDTO,statusDataDTO);
+        when(replayRepository.getReplayStatusByReplayId(replayId)).thenReturn(replayMetaDataDTOList);
+        ReplayStatusResponse response = replayService.getReplayStatus(replayId);
+        assertNotNull(response);
+        assertNotNull(response.getFilter());
+        assertEquals(response.getOverallState(),"COMPLETED");
+    }
+}
diff --git a/testing/storage-test-azure/src/test/java/org/opengroup/osdu/storage/replay/TestReplayEndpoint.java b/testing/storage-test-azure/src/test/java/org/opengroup/osdu/storage/replay/TestReplayEndpoint.java
new file mode 100644
index 0000000000000000000000000000000000000000..8276c46d5a4507990955bfcf4c6f3724bcfe8bbd
--- /dev/null
+++ b/testing/storage-test-azure/src/test/java/org/opengroup/osdu/storage/replay/TestReplayEndpoint.java
@@ -0,0 +1,50 @@
+// Copyright 2017-2019, Schlumberger
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.replay;
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.opengroup.osdu.storage.Replay.ReplayEndpointsTests;
+import org.opengroup.osdu.storage.util.AzureTestUtils;
+import org.opengroup.osdu.storage.util.ConfigUtils;
+
+public class TestReplayEndpoint extends ReplayEndpointsTests {
+
+    private static final AzureTestUtils azureTestUtils = new AzureTestUtils();
+
+    @BeforeClass
+    public static void classSetup() throws Exception {
+        ReplayEndpointsTests.classSetup(azureTestUtils.getToken());
+    }
+
+    @AfterClass
+    public static void classTearDown() throws Exception {
+        ReplayEndpointsTests.classTearDown(azureTestUtils.getToken());
+    }
+
+    @Before
+    @Override
+    public void setup() throws Exception {
+        this.testUtils = new AzureTestUtils();
+        this.configUtils = new ConfigUtils("test.properties");
+    }
+
+    @After
+    @Override
+    public void tearDown() throws Exception {
+        this.testUtils = null;
+    }
+}
diff --git a/testing/storage-test-azure/src/test/resources/test.properties b/testing/storage-test-azure/src/test/resources/test.properties
index 26a19c56cf9602627da575c3c07b44feb621bf59..fc07826a8fd1bdf7096af5bdd7ccca19985837e7 100644
--- a/testing/storage-test-azure/src/test/resources/test.properties
+++ b/testing/storage-test-azure/src/test/resources/test.properties
@@ -17,3 +17,9 @@ enableEncodedSpecialCharactersInURL=true
 schema.endpoints.disabled=true
 
 collaboration.enabled=false
+
+# Mark is true for ADME
+test.replayAll.enabled = false
+
+#For ADME set it to 6000
+test.replayAll.timeout = 60
diff --git a/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/Replay/ReplayEndpointsTests.java b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/Replay/ReplayEndpointsTests.java
new file mode 100644
index 0000000000000000000000000000000000000000..a22e68fd044e3b26fc7f2d8bd6ac5894b621a385
--- /dev/null
+++ b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/Replay/ReplayEndpointsTests.java
@@ -0,0 +1,336 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.Replay;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import org.apache.hc.core5.http.io.entity.EntityUtils;
+import org.apache.http.HttpStatus;
+
+import com.google.gson.Gson;
+import org.junit.Test;
+import org.opengroup.osdu.storage.model.ReplayStatusResponseHelper;
+import org.opengroup.osdu.storage.records.RecordsApiAcceptanceTests;
+import org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;
+import org.opengroup.osdu.storage.util.DummyRecordsHelper;
+import org.opengroup.osdu.storage.util.HeaderUtils;
+import org.opengroup.osdu.storage.util.LegalTagUtils;
+import org.opengroup.osdu.storage.util.ReplayUtils;
+import org.opengroup.osdu.storage.util.TenantUtils;
+import org.opengroup.osdu.storage.util.TestBase;
+import org.opengroup.osdu.storage.util.TestUtils;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+public abstract class ReplayEndpointsTests extends TestBase {
+    protected static String LEGAL_TAG_NAME = LegalTagUtils.createRandomName();
+
+    protected static final String INVALID_KIND = TenantUtils.getTenantName() + ":ds:1.0."
+            + System.currentTimeMillis();
+
+    public static void classSetup(String token) throws Exception {
+
+        LegalTagUtils.create(LEGAL_TAG_NAME, token);
+    }
+
+    public static void classTearDown(String token) throws Exception {
+
+        LegalTagUtils.delete(LEGAL_TAG_NAME, token);
+    }
+
+    @Test
+    public void should_return_400_when_givenNoOperationNameIsNotInRequest() throws Exception {
+
+        String requestBody = ReplayUtils.createJsonEmpty();
+        CloseableHttpResponse response = TestUtils.send("replay", "POST", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), requestBody, "");
+        assertEquals(400, response.getCode());
+        String actualErrorMessage = ReplayUtils.getFieldFromResponse(response, "message");
+        assertEquals(400, response.getCode());
+        assertEquals("Operation field is required. The valid operations are: 'replay', 'reindex'.", actualErrorMessage);
+    }
+
+    @Test
+    public void should_return_400_when_givenKindIsEmpty() throws Exception {
+
+        String requestBody = ReplayUtils.createJsonWithKind("reindex", new ArrayList<>());
+        CloseableHttpResponse response = TestUtils.send("replay", "POST", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), requestBody, "");
+        String actualErrorMessage = ReplayUtils.getFieldFromResponse(response, "message");
+        assertEquals(400, response.getCode());
+        assertEquals("Currently restricted to a single valid kind.", actualErrorMessage);
+    }
+
+    @Test
+    public void should_return_400_when_givenKindSizeIsGreaterDenOne() throws Exception {
+
+        List<String> kindList = new ArrayList<>();
+        kindList.add(getKind());
+        kindList.add(getKind());
+
+        String requestBody = ReplayUtils.createJsonWithKind("reindex", kindList);
+        CloseableHttpResponse response = TestUtils.send("replay", "POST", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), requestBody, "");
+        String actualErrorMessage = ReplayUtils.getFieldFromResponse(response, "message");
+        assertEquals(400, response.getCode());
+        assertEquals("Currently restricted to a single valid kind.", actualErrorMessage);
+    }
+
+    @Test
+    public void Should_return_400_when_givenInvalidKind() throws Exception {
+
+        List<String> kindList = new ArrayList<>();
+        kindList.add(INVALID_KIND);
+        String requestBody = ReplayUtils.createJsonWithKind("reindex", kindList);
+        CloseableHttpResponse response = TestUtils.send("replay", "POST", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), requestBody, "");
+        String actualErrorMessage = ReplayUtils.getFieldFromResponse(response, "message");
+        assertEquals(400, response.getCode());
+        assertEquals("The requested kind does not exist.", actualErrorMessage);
+    }
+
+    @Test
+    public void Should_return_400_when_givenInvalidOperationName() throws Exception {
+
+        String requestBody = ReplayUtils.createJsonWithOperationName("invalidOperation");
+        CloseableHttpResponse response = TestUtils.send("replay", "POST", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), requestBody, "");
+        String actualErrorMessage = ReplayUtils.getFieldFromResponse(response, "message");
+        assertEquals(400, response.getCode());
+        assertEquals("Not a valid operation. The valid operations are: [reindex, replay]", actualErrorMessage);
+    }
+
+    @Test
+    public void should_return_200_GivenReplayAll() throws Exception {
+
+        if (configUtils != null && configUtils.getIsTestReplayAllEnabled()) {
+
+            String kind_1 = getKind();
+            String kind_2 = getKind();
+            List<String> givenKindList = Arrays.asList(kind_1, kind_2);
+            List<String> totalRecordIds = this.createTestRecordForGivenCapacityAndKinds(500, 100, givenKindList);
+
+            DummyRecordsHelper dummyRecordsHelper = new DummyRecordsHelper();
+
+            CloseableHttpResponse response = TestUtils.send("query/kinds", "GET", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), "", "?limit=10");
+            assertEquals(HttpStatus.SC_OK, response.getCode());
+            DummyRecordsHelper.QueryResultMock responseObject = dummyRecordsHelper.getQueryResultMockFromResponse(response);
+            List<String> kindList = new ArrayList<>(Arrays.asList(responseObject.results));
+            kindList.add(kind_1);
+            kindList.add(kind_2);
+
+            performValidationBeforeOrAfterReplay(kindList, givenKindList, "*:*:*:*", 2000);
+            String requestBody = ReplayUtils.createJsonWithOperationName("reindex");
+            ReplayStatusResponseHelper replayStatusResponseHelper = this.performReplay(requestBody);
+            assertEquals("reindex", replayStatusResponseHelper.getOperation());
+
+            assertNull(replayStatusResponseHelper.getFilter());
+            assertEquals(1, replayStatusResponseHelper.getStatus().size());
+            performValidationBeforeOrAfterReplay(kindList, givenKindList, "*:*:*:*", 2000);
+        }
+    }
+
+    @Test(timeout = 2000)
+    public void should_return_200_givenSingleKind() throws Exception {
+
+        if (configUtils != null && configUtils.getIsTestReplayAllEnabled()) {
+
+            String kind_1 = getKind();
+            List<String> kindList = new ArrayList<>();
+            kindList.add(kind_1);
+            List<String> ids = this.createTestRecordForGivenCapacityAndKinds(1, 1, kindList);
+
+            performValidationBeforeOrAfterReplay(kindList, kindList, kind_1, 1);
+            String requestBody = ReplayUtils.createJsonWithKind("reindex", kindList);
+            ReplayStatusResponseHelper replayStatusResponseHelper = performReplay(requestBody);
+
+            assertEquals("reindex", replayStatusResponseHelper.getOperation());
+            assertEquals(1, replayStatusResponseHelper.getFilter().getKinds().size());
+            assertEquals(1, replayStatusResponseHelper.getStatus().size());
+            assertEquals(kind_1, replayStatusResponseHelper.getFilter().getKinds().get(0));
+
+            performValidationBeforeOrAfterReplay(kindList, kindList, kind_1, 1);
+            deleteRecords(ids);
+        }
+    }
+
+    public List<String> createTestRecordForGivenCapacityAndKinds(int n, int factor, List<String> kinds) throws Exception {
+
+        int totalRecordCount = n * kinds.size();
+        long startTime = System.currentTimeMillis();
+        List<String> totalIds = new ArrayList<>();
+        for (String kind : kinds) {
+            int counter = n;
+            while (counter > 0) {
+                List<String> listIds = create_N_TestRecordForGivenKind(factor, kind);
+                totalIds = Stream.concat(totalIds.stream(), listIds.stream()).collect(Collectors.toList());
+                counter -= factor;
+                Thread.sleep(1000);
+            }
+
+        }
+
+        Thread.sleep(40000);
+        return totalIds;
+    }
+
+    @Test
+    public void should_return_400_when_givenEmptyJSONIsSent() throws Exception {
+
+        String requestBody = ReplayUtils.createJsonEmpty();
+        CloseableHttpResponse response = TestUtils.send("replay", "POST", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), requestBody, "");
+        assertEquals(400, response.getCode());
+    }
+
+    protected List<String> create_N_TestRecordForGivenKind(int n, String kind) throws Exception {
+
+        String json = "";
+        List<String> ids = new ArrayList<>(n);
+        for (int i = 0; i < n; i++) {
+            String id1 = TenantUtils.getTenantName() + ":inttest:" + System.currentTimeMillis() + i;
+            json += RecordsApiAcceptanceTests.singleEntityBody(id1, "ash ketchum", kind, LEGAL_TAG_NAME);
+            if (i != n - 1) {
+                json += ",";
+            }
+            ids.add(id1);
+        }
+
+        json = "[" + json + "]";
+
+        CloseableHttpResponse response = TestUtils.send("records", "PUT", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), json, "");
+
+        String responseJson = EntityUtils.toString(response.getEntity());
+        assertEquals(201, response.getCode());
+        Gson gson = new Gson();
+        DummyRecordsHelper.CreateRecordResponse result = gson.fromJson(
+                responseJson,
+                DummyRecordsHelper.CreateRecordResponse.class
+                                                                      );
+        assertEquals(n, result.recordCount);
+        assertEquals(n, result.recordIds.length);
+        assertEquals(n, result.recordIdVersions.length);
+
+        return ids;
+    }
+
+    private void performValidationBeforeOrAfterReplay(List<String> kinds, List<String> givenKindList, String kindType, int totalReplayAllRecord) throws Exception {
+
+        long startTime = System.currentTimeMillis();
+        CloseableHttpResponse response = null;
+
+        int initialRecordCount = 0;
+        int countNoOfAPICalls = 0;
+        while ((initialRecordCount = getIndexedRecordCount(givenKindList)) != totalReplayAllRecord) {
+            if (countNoOfAPICalls > 10)
+                fail();
+
+            Thread.sleep(configUtils.getTimeoutForReplay());
+            countNoOfAPICalls++;
+        }
+
+        assertEquals(totalReplayAllRecord, initialRecordCount);
+
+        System.out.println("Total count for Kind " + kindType + " is " + initialRecordCount);
+
+        for (String kind : kinds) {
+            response = TestUtils.send(ReplayUtils.getIndexerUrl(), "index?kind=" + kind, "DELETE", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), "", "");
+            Thread.sleep(1000);
+        }
+
+        int countOfRecord = getIndexedRecordCount(givenKindList);
+        System.out.println("Total count for Kind " + kindType + " after deletion is " + countOfRecord);
+        assertEquals(0, countOfRecord);
+
+        System.out.println("The end time for performValidationBeforeOrAfterReplay for KindType " + kindType + "is " + (System.currentTimeMillis() - startTime));
+    }
+
+    private ReplayStatusResponseHelper performReplay(String requestBody) throws Exception {
+
+        CloseableHttpResponse response = TestUtils.send("replay", "POST", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), requestBody, "");
+
+        if (response.getCode() == 500)
+            System.out.println("Error in replay call  " + ReplayUtils.getFieldFromResponse(response, "message"));
+
+        assertEquals(202, response.getCode());
+
+        String replayId = ReplayUtils.getFieldFromResponse(response, "replayId");
+        response = TestUtils.send("replay/status/", "GET", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), "", replayId);
+
+        ReplayStatusResponseHelper replayStatusResponseHelper = ReplayUtils.getConvertedReplayStatusResponseFromResponse(response);
+        System.out.println("Total Number of Record to be Processed for Replay " + replayStatusResponseHelper.getTotalRecords());
+
+        int countNoOfAPICalls = 0;
+
+        while (!replayStatusResponseHelper.getOverallState().equals("COMPLETED")) {
+            assertNotEquals("FAILED", replayStatusResponseHelper.getOverallState());
+            response = TestUtils.send("replay/status/", "GET", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), "", replayId);
+            replayStatusResponseHelper = ReplayUtils.getConvertedReplayStatusResponseFromResponse(response);
+            if (replayStatusResponseHelper.getStatus() != null && !replayStatusResponseHelper.getStatus().isEmpty())
+                System.out.println("Number of Record to be Processed for Replay  " + replayStatusResponseHelper.getStatus().get(0).getProcessedRecords());
+
+            if (countNoOfAPICalls > 10)
+                 fail();
+
+            Thread.sleep(configUtils.getTimeoutForReplay());
+            countNoOfAPICalls++;
+        }
+
+        assertEquals(replayId, replayStatusResponseHelper.getReplayId());
+        return replayStatusResponseHelper;
+    }
+
+    protected void deleteRecords(List<String> ids) {
+
+        long startTime = System.currentTimeMillis();
+
+        ids.parallelStream().forEach((id) -> {
+            try {
+                TestUtils.send("records/" + id, "DELETE", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), "", "");
+            } catch (Exception e) {
+            }
+        });
+
+        System.out.println("The totalTime for delete Records for size " + ids.size() + "is " + (System.currentTimeMillis() - startTime));
+    }
+
+    private int getIndexedRecordCount(List<String> kinds) throws Exception {
+
+        int recordCountIndexed = 0;
+        for (String kind : kinds) {
+            String requestBody = ReplayUtils.getSearchCountQueryForKind(kind);
+            CloseableHttpResponse response = TestUtils.send(ReplayUtils.getSearchUrl(), "query", "POST", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), requestBody, "");
+            recordCountIndexed += Integer.parseInt(ReplayUtils.getFieldFromResponse(response, "totalCount"));
+
+        }
+        return recordCountIndexed;
+    }
+
+    @Test
+    public void should_return_400_when_givenInvalidReplayID() throws Exception {
+
+        CloseableHttpResponse response = TestUtils.send("replay/status/", "GET", HeaderUtils.getHeaders(TenantUtils.getTenantName(), testUtils.getToken()), "", "1234");
+        String actualErrorMessage = ReplayUtils.getFieldFromResponse(response, "message");
+        assertEquals("The replay ID 1234 is invalid.", actualErrorMessage);
+        assertEquals(404, response.getCode());
+    }
+
+    public static String getKind() throws InterruptedException {
+
+        Thread.sleep(1);
+        return TenantUtils.getTenantName() + ":ds:inttest:1.0." + System.nanoTime();
+    }
+}
diff --git a/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/model/ReplayFilter.java b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/model/ReplayFilter.java
new file mode 100644
index 0000000000000000000000000000000000000000..9d9867bb529f30997229d1a8e3d192fe27052daf
--- /dev/null
+++ b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/model/ReplayFilter.java
@@ -0,0 +1,31 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.model;
+
+
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import java.util.List;
+
+@Data
+@Builder
+@NoArgsConstructor
+@AllArgsConstructor
+public class ReplayFilter {
+
+    private List<String> kinds;
+}
diff --git a/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/model/ReplayStatus.java b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/model/ReplayStatus.java
new file mode 100644
index 0000000000000000000000000000000000000000..965cda2c1879edd189f032a662c4a10fb7d1fb92
--- /dev/null
+++ b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/model/ReplayStatus.java
@@ -0,0 +1,41 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.model;
+
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import java.util.Date;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@Builder
+public class ReplayStatus {
+
+    private String kind;
+
+    private Long totalRecords;
+
+    private Long processedRecords;
+
+    private String state;
+
+    private Date startedAt;
+
+    private String elapsedTime;
+}
diff --git a/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/model/ReplayStatusResponseHelper.java b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/model/ReplayStatusResponseHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..5fa7f6317931c37c5a1aae57b96079613c11775d
--- /dev/null
+++ b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/model/ReplayStatusResponseHelper.java
@@ -0,0 +1,50 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.model;
+
+import lombok.AllArgsConstructor;
+import lombok.Builder;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+import org.opengroup.osdu.storage.model.ReplayFilter;
+
+
+import java.util.Date;
+import java.util.List;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@Builder
+public class ReplayStatusResponseHelper {
+
+    private String replayId;
+
+    private String operation;
+
+    private Long totalRecords;
+
+    private Date startedAt;
+
+    private String elapsedTime;
+
+    private Long processedRecords;
+
+    private String overallState;
+
+    private ReplayFilter filter;
+
+    private List<ReplayStatus> status;
+}
diff --git a/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/query/GetQueryKindsIntegrationTests.java b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/query/GetQueryKindsIntegrationTests.java
index 2cbcd891b074c52a36db7b53ef6710a630e6768b..20b6b7cd5ec072b3603e0496ebe7574638a29c2d 100644
--- a/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/query/GetQueryKindsIntegrationTests.java
+++ b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/query/GetQueryKindsIntegrationTests.java
@@ -63,4 +63,4 @@ public abstract class GetQueryKindsIntegrationTests extends TestBase {
 			assertEquals(2, responseObject.results.length);
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/util/ConfigUtils.java b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/util/ConfigUtils.java
index 205034bcbf3bb1e372c1b7cd860b4cabab9cebd7..be1e6fe2eca0ed3922a23e28095110879930d74d 100644
--- a/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/util/ConfigUtils.java
+++ b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/util/ConfigUtils.java
@@ -39,10 +39,20 @@ public class ConfigUtils {
         return Boolean.parseBoolean(propValue);
     }
 
+    public long getLongProperty(String propertyName, String defaultValue) {
+        String propValue = properties.getProperty(propertyName, defaultValue);
+        return Long.parseLong(propValue);
+    }
+
     public boolean getIsSchemaEndpointsEnabled() {
         return !getBooleanProperty("schema.endpoints.disabled", "true");
     }
     public boolean getIsCollaborationEnabled() {
         return getBooleanProperty("collaboration.enabled", "false");
     }
+
+    public boolean getIsTestReplayAllEnabled() { return  getBooleanProperty("test.replayAll.enabled", "false");}
+
+    public long getTimeoutForReplay() { return  getLongProperty("test.replayAll.timeout", "60");}
+
 }
diff --git a/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/util/ReplayUtils.java b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/util/ReplayUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..5253e2244b9666504a71edc51634a6a2da6660a4
--- /dev/null
+++ b/testing/storage-test-core/src/main/java/org/opengroup/osdu/storage/util/ReplayUtils.java
@@ -0,0 +1,121 @@
+// Copyright © Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package org.opengroup.osdu.storage.util;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;
+import org.apache.hc.core5.http.ParseException;
+import org.apache.hc.core5.http.ProtocolException;
+import org.apache.hc.core5.http.io.entity.EntityUtils;
+import org.opengroup.osdu.core.common.model.http.AppException;
+import org.opengroup.osdu.storage.model.ReplayStatusResponseHelper;
+
+import java.io.IOException;
+import java.util.List;
+public class ReplayUtils {
+
+    public static String createJsonEmpty() {
+
+        JsonObject requestBody = new JsonObject();
+        return requestBody.toString();
+    }
+
+    public static String createJsonWithoutOperationName(List<String> kindList) {
+
+        JsonObject requestBody = new JsonObject();
+        JsonObject filter = new JsonObject();
+        requestBody.add("filter", filter);
+        JsonArray kindArray = new JsonArray();
+        filter.add("kinds", kindArray);
+        for (String kind : kindList)
+            kindArray.add(kind);
+        return requestBody.toString();
+    }
+
+
+    public static String createJsonWithOperationName(String operation) {
+
+        JsonObject requestBody = new JsonObject();
+        requestBody.addProperty("operation", operation);
+        return requestBody.toString();
+    }
+
+    public static String createJsonWithEmptyFilter(String operation) {
+
+        JsonObject requestBody = new JsonObject();
+        requestBody.addProperty("operation", operation);
+        JsonObject filter = new JsonObject();
+        requestBody.add("filter", filter);
+        return requestBody.toString();
+    }
+
+    public static String createJsonWithKind(String operation, List<String> kindList) {
+
+        JsonObject requestBody = new JsonObject();
+        JsonObject filter = new JsonObject();
+        JsonArray kindArray = new JsonArray();
+        requestBody.addProperty("operation", operation);
+        requestBody.add("filter", filter);
+        filter.add("kinds", kindArray);
+        for (String kind : kindList)
+            kindArray.add(kind);
+        return requestBody.toString();
+    }
+
+    public static String getFieldFromResponse(CloseableHttpResponse response, String field) throws IOException, ParseException {
+
+        return JsonParser.parseString(EntityUtils.toString(response.getEntity()))
+                         .getAsJsonObject()
+                         .get(field)
+                         .getAsString();
+    }
+
+    public static String getSearchCountQueryForKind(String kind) {
+
+        JsonObject requestBody = new JsonObject();
+        requestBody.addProperty("kind", kind);
+        requestBody.addProperty("limit", 1);
+        requestBody.addProperty("trackTotalCount", true);
+        return requestBody.toString();
+    }
+
+    public static String getSearchUrl() {
+
+        String searchUrl = System.getProperty("SEARCH_URL", System.getenv("SEARCH_URL"));
+        if (searchUrl == null || searchUrl.contains("-null")) {
+            throw new IllegalArgumentException("Invalid SEARCH_URL: " + searchUrl);
+        }
+        return searchUrl;
+    }
+
+    public static String getIndexerUrl() {
+
+        String indexerUrl = System.getProperty("INDEXER_URL", System.getenv("INDEXER_URL"));
+        if (indexerUrl == null || indexerUrl.contains("-null")) {
+            throw new IllegalArgumentException("Invalid INDEXER_URL: " + indexerUrl);
+        }
+        return indexerUrl;
+    }
+
+    public static ReplayStatusResponseHelper getConvertedReplayStatusResponseFromResponse(CloseableHttpResponse response) throws ProtocolException, IOException {
+
+        String json = EntityUtils.toString(response.getEntity());
+        Gson gson = new Gson();
+        return gson.fromJson(json, ReplayStatusResponseHelper.class);
+    }
+}
